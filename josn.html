<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JSON Editor - ファイルツリー風エディタ</title>
<style>
  /* ページ全体のスタイル */
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #2c2f33;
    color: #f6f6f6;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
  
  /* ヘッダーセクション */
  #header {
    background-color: #23272a;
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 2px solid #7289da;
    box-shadow: 0 2px 10px rgba(0,0,0,0.5);
  }
  #header h1 {
    margin: 0;
    font-size: 1.5em;
    color: #7289da;
  }
  #controls {
    display: flex;
    gap: 10px;
  }

  /* ボタンの基本スタイル */
  .btn {
    padding: 8px 15px;
    background-color: #5865f2;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 0.9em;
    transition: background-color 0.3s, transform 0.2s;
  }
  .btn:hover {
    background-color: #4752c4;
    transform: translateY(-2px);
  }
  .btn-secondary {
    background-color: #4f545c;
  }
  .btn-secondary:hover {
    background-color: #3b3e44;
  }
  .btn-danger {
    background-color: #ff5555;
  }
  .btn-danger:hover {
    background-color: #cc4444;
  }

  /* メインコンテンツエリア */
  #main {
    flex: 1;
    display: flex;
    padding: 20px;
    gap: 20px;
    overflow: hidden;
  }

  /* ファイル読み込みゾーン */
  #file-zone {
    width: 300px;
    background-color: #23272a;
    border: 2px dashed #4f545c;
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    transition: background-color 0.3s, border-color 0.3s;
  }
  #file-zone.dragover {
    background-color: #3b3e44;
    border-color: #7289da;
  }

  /* エディタ表示セクション */
  #json-display {
    flex: 1;
    background-color: #23272a;
    border-radius: 10px;
    padding: 15px;
    display: flex;
    flex-direction: column;
  }
  #editor-controls {
    display: flex;
    justify-content: space-between;
    margin-bottom: 15px;
    gap: 10px;
  }
  #search-box {
    flex: 1;
    padding: 8px;
    border-radius: 5px;
    border: 1px solid #4f545c;
    background-color: #3b3e44;
    color: #f6f6f6;
    font-size: 1em;
  }

  /* エディタモード切替ボタン */
  .editor-mode-btn {
    padding: 8px 15px;
    border: 1px solid #4f545c;
    border-radius: 5px;
    background-color: #3b3e44;
    color: #f6f6f6;
    cursor: pointer;
  }
  .editor-mode-btn.active {
    background-color: #5865f2;
    border-color: #5865f2;
  }

  /* ツリービュー */
  #tree-view {
    flex: 1;
    overflow: auto;
    font-family: 'monospace', sans-serif;
    font-size: 14px;
    white-space: nowrap;
    user-select: none;
    line-height: 24px;
  }
  #text-editor {
    flex: 1;
    width: 100%;
    background-color: #3b3e44;
    color: #f6f6f6;
    border: 1px solid #4f545c;
    border-radius: 5px;
    padding: 15px;
    font-family: monospace;
    font-size: 14px;
    resize: none;
    display: none;
  }
  
  /* ファイルツリー風デザインのスタイル */
  .node-wrapper {
    display: flex;
    align-items: center;
    position: relative;
    padding-left: 10px;
    cursor: pointer;
  }
  
  .node-wrapper.root {
    padding-left: 0;
  }

  .nested-container {
    padding-left: 20px;
  }

  .toggle {
    display: inline-block;
    width: 16px;
    text-align: center;
    color: #f6f6f6;
    font-size: 10px;
    margin-right: 5px;
    user-select: none;
  }
  .icon {
    margin-right: 5px;
  }
  .key {
    color: #d1b8ff;
  }
  .value {
    color: #f6f6f6;
  }
  .string {
    color: #92d0ff;
  }
  .number {
    color: #ff91b8;
  }
  .boolean {
    color: #99ffb4;
  }
  .null {
    color: #f5da90;
  }
  .colon {
    color: #f6f6f6;
  }

  /* ノード右側の操作ボタン */
  .node-controls {
    display: none;
    margin-left: 10px;
    gap: 5px;
  }
  .node-controls button, .node-controls select {
    background: #3b3e44;
    border: none;
    color: white;
    padding: 3px 6px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.8em;
  }
  .node-controls button:hover, .node-controls select:hover {
    background: #4f545c;
  }
  .node-wrapper:hover .node-controls {
    display: flex;
  }
  
  /* インライン編集のスタイル */
  .inline-edit {
    background-color: #3b3e44;
    color: #f6f6f6;
    border: 1px solid #7289da;
    border-radius: 3px;
    font-family: monospace;
    font-size: 1em;
    padding: 2px;
  }

  /* 検索ハイライト */
  .search-highlight {
    background-color: #ffbf00;
    color: #333;
    border-radius: 3px;
  }
</style>
</head>
<body>

<!-- ヘッダー -->
<div id="header">
  <h1>JSON Editor</h1>
  <div id="controls">
    <button id="importBtn" class="btn">📂 ファイルを開く</button>
    <button id="saveBtn" class="btn btn-secondary" disabled>💾 JSONとして保存</button>
    <button id="saveToLocalBtn" class="btn">保存</button>
    <button id="loadFromLocalBtn" class="btn">読込</button>
  </div>
</div>

<!-- メインコンテンツ -->
<div id="main">
  <!-- ファイルのドラッグ＆ドロップゾーン -->
  <div id="file-zone">
    <span>ここにJSONファイルをドラッグ＆ドロップ</span>
    <span>または</span>
    <button id="fileBtn" class="btn">ファイルを選択</button>
  </div>

  <!-- JSONエディタセクション (初期状態では非表示) -->
  <div id="json-display">
    <div id="editor-controls">
      <input type="text" id="search-box" placeholder="キーまたは値を検索...">
      <button class="editor-mode-btn active" data-mode="tree">ツリー</button>
      <button class="editor-mode-btn" data-mode="text">テキスト</button>
      <button id="formatBtn" class="btn btn-secondary">📄 整形</button>
    </div>
    <div id="tree-view"></div>
    <textarea id="text-editor"></textarea>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const fileZone = document.getElementById('file-zone');
    const fileBtn = document.getElementById('fileBtn');
    const importBtn = document.getElementById('importBtn');
    const saveBtn = document.getElementById('saveBtn');
    const saveToLocalBtn = document.getElementById('saveToLocalBtn');
    const loadFromLocalBtn = document.getElementById('loadFromLocalBtn');
    const jsonDisplay = document.getElementById('json-display');
    const treeView = document.getElementById('tree-view');
    const textEditor = document.getElementById('text-editor');
    const searchBox = document.getElementById('search-box');
    const formatBtn = document.getElementById('formatBtn');
    const modeBtns = document.querySelectorAll('.editor-mode-btn');

    let currentData = null;
    let editorMode = 'tree';

    // 初期データの設定
    initializeEditor();

    // === 初期化とファイル処理 ===
    function initializeEditor() {
        // 初期データを設定
        currentData = {
          "user": {
            "name": "山田太郎",
            "age": 30,
            "isAdmin": false,
            "hobbies": ["読書", "プログラミング", "料理"],
            "contacts": {
              "email": "taro.yamada@example.com",
              "phone": "090-1234-5678"
            }
          },
          "lastLogin": null
        };
        displayData();
        fileZone.style.display = 'none';
        jsonDisplay.style.display = 'flex';
        updateSaveButton();
    }

    // ドラッグ＆ドロップイベントリスナー
    fileZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        fileZone.classList.add('dragover');
    });
    fileZone.addEventListener('dragleave', () => {
        fileZone.classList.remove('dragover');
    });
    fileZone.addEventListener('drop', (e) => {
        e.preventDefault();
        fileZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) handleFile(file);
    });

    // ファイル選択ボタンのクリックイベント
    fileBtn.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        };
        input.click();
    });
    importBtn.addEventListener('click', () => fileBtn.click());

    // ファイルを読み込んで処理する関数
    function handleFile(file) {
        if (!file.name.endsWith('.json')) {
            alert('JSONファイルを選択してください。');
            return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                currentData = JSON.parse(e.target.result);
                displayData();
                fileZone.style.display = 'none';
                jsonDisplay.style.display = 'flex';
                updateSaveButton();
                switchMode('tree');
            } catch (err) {
                alert('無効なJSONファイルです: ' + err.message);
            }
        };
        reader.readAsText(file);
    }

    // === 保存機能 ===
    saveBtn.addEventListener('click', () => {
        if (!currentData) return;
        const dataToSave = editorMode === 'tree' ? currentData : JSON.parse(textEditor.value);
        const jsonStr = JSON.stringify(dataToSave, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'edited_data.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });

    function updateSaveButton() {
        saveBtn.disabled = !currentData;
        saveBtn.style.opacity = currentData ? 1 : 0.5;
    }

    // === ローカルストレージ機能 ===
    const LOCAL_STORAGE_KEY = "json-editor-data";

    saveToLocalBtn.addEventListener('click', () => {
        if (!currentData) {
            alert("保存するデータがありません。");
            return;
        }
        try {
            const dataToSave = editorMode === 'tree' ? currentData : JSON.parse(textEditor.value);
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
            alert("データをローカルストレージに保存しました。");
        } catch (e) {
            alert("データの保存に失敗しました。");
        }
    });

    loadFromLocalBtn.addEventListener('click', () => {
        const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (storedData) {
            try {
                currentData = JSON.parse(storedData);
                displayData();
                fileZone.style.display = 'none';
                jsonDisplay.style.display = 'flex';
                updateSaveButton();
                switchMode('tree');
                alert("データをローカルストレージから読み込みました。");
            } catch (e) {
                alert("データの読み込みに失敗しました。");
            }
        } else {
            alert("ローカルストレージに保存されたデータが見つかりません。");
        }
    });


    // === エディタモード切替 ===
    modeBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const mode = btn.getAttribute('data-mode');
            switchMode(mode);
        });
    });

    function switchMode(mode) {
        editorMode = mode;
        modeBtns.forEach(btn => btn.classList.toggle('active', btn.getAttribute('data-mode') === mode));

        if (mode === 'tree') {
            try {
                const textValue = textEditor.value.trim();
                if (textValue) {
                    currentData = JSON.parse(textValue);
                    displayData();
                }
                treeView.style.display = 'block';
                textEditor.style.display = 'none';
            } catch (e) {
                alert('テキストモードのJSONが無効です。ツリーモードに切り替えられません。');
                return;
            }
        } else {
            treeView.style.display = 'none';
            textEditor.style.display = 'block';
            textEditor.value = JSON.stringify(currentData, null, 2);
        }
    }

    // === JSONツリービューのレンダリング ===
    function displayData(data = currentData, parentEl = treeView, parentPath = [], isRoot = true) {
        parentEl.innerHTML = '';
        if (typeof data !== 'object' || data === null) {
            parentEl.appendChild(createNodeElement(parentPath.at(-1), data, parentPath));
            return;
        }
        
        const entries = Object.entries(data);
        entries.forEach(([key, value], index) => {
            const path = [...parentPath, key];
            parentEl.appendChild(createNodeElement(key, value, path, isRoot));
        });
    }

    function createNodeElement(key, value, path, isRoot) {
        const nodeWrapper = document.createElement('div');
        nodeWrapper.className = `node-wrapper ${isRoot ? 'root' : ''}`;
        nodeWrapper.dataset.path = JSON.stringify(path);

        let valueType = typeof value;
        if (value === null) valueType = 'null';
        if (Array.isArray(value)) valueType = 'array';
        if (valueType === 'object' && value !== null) valueType = 'object';

        const nodeContent = document.createElement('div');
        nodeContent.style.display = 'flex';
        nodeContent.style.alignItems = 'center';
        nodeContent.style.flexWrap = 'wrap'; /* ボタンが重ならないように折り返す */

        // アイコンとトグル
        const toggleIcon = document.createElement('span');
        const icon = document.createElement('span');
        icon.className = 'icon';

        if (valueType === 'object') {
            toggleIcon.className = 'toggle';
            toggleIcon.textContent = '▼';
            icon.textContent = '📁';
        } else if (valueType === 'array') {
            toggleIcon.className = 'toggle';
            toggleIcon.textContent = '▼';
            icon.textContent = '📁'; // 配列もフォルダとして扱う
        } else {
            toggleIcon.style.width = '16px';
            toggleIcon.style.display = 'inline-block';
            icon.textContent = '📄';
        }
        nodeContent.appendChild(toggleIcon);
        nodeContent.appendChild(icon);

        // キーと値の表示
        const keySpan = document.createElement('span');
        keySpan.className = 'key';
        keySpan.textContent = isRoot ? '/' : key; // ルートノードは '/'
        nodeContent.appendChild(keySpan);

        if (valueType !== 'object' && valueType !== 'array') {
            const colon = document.createElement('span');
            colon.className = 'colon';
            colon.textContent = ':';
            nodeContent.appendChild(colon);

            const valueSpan = document.createElement('span');
            valueSpan.className = valueType;
            if (valueType === 'string') {
                valueSpan.textContent = ` "${value}"`;
            } else {
                valueSpan.textContent = ` ${value}`;
            }
            nodeContent.appendChild(valueSpan);
        }

        nodeWrapper.appendChild(nodeContent);

        // ノード右側の操作ボタンを追加
        const controls = document.createElement('div');
        controls.className = 'node-controls';

        // フォルダ・ファイル追加ボタン
        if (valueType === 'object' || valueType === 'array') {
            const addBtn = document.createElement('button');
            addBtn.textContent = '＋';
            addBtn.title = 'ノードを追加';
            addBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (Array.isArray(value)) {
                    value.push("");
                } else {
                    value['new_key'] = "";
                }
                displayData();
            });
            controls.appendChild(addBtn);
        }

        // 複製ボタン
        const dupBtn = document.createElement('button');
        dupBtn.textContent = 'D';
        dupBtn.title = 'ノードを複製';
        dupBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const parent = getNode(path.slice(0, -1));
            const item = getNode(path);
            if (Array.isArray(parent)) {
                parent.splice(parseInt(path.at(-1)) + 1, 0, JSON.parse(JSON.stringify(item)));
            } else {
                parent[`${path.at(-1)}_copy`] = JSON.parse(JSON.stringify(item));
            }
            displayData();
        });
        controls.appendChild(dupBtn);

        // 削除ボタン
        const delBtn = document.createElement('button');
        delBtn.textContent = 'x';
        delBtn.title = 'ノードを削除';
        delBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const parent = getNode(path.slice(0, -1));
            if (Array.isArray(parent)) {
                parent.splice(parseInt(path.at(-1)), 1);
            } else {
                delete parent[path.at(-1)];
            }
            displayData();
        });
        controls.appendChild(delBtn);

        // 型変換ボタン
        const typeSelect = document.createElement('select');
        typeSelect.innerHTML = `
            <option value="string" ${typeof value === 'string' ? 'selected' : ''}>S</option>
            <option value="number" ${typeof value === 'number' ? 'selected' : ''}>N</option>
            <option value="boolean" ${typeof value === 'boolean' ? 'selected' : ''}>B</option>
            <option value="null" ${value === null ? 'selected' : ''}>0</option>
            `;
        typeSelect.title = '型変換';
        typeSelect.addEventListener('change', (e) => {
            const newType = e.target.value;
            let convertedValue = value;
            switch (newType) {
                case 'string':
                    convertedValue = String(value);
                    break;
                case 'number':
                    convertedValue = Number(value);
                    if (isNaN(convertedValue)) {
                        alert('数値に変換できません。');
                        convertedValue = value;
                    }
                    break;
                case 'boolean':
                    convertedValue = (value === 'true' || value === '1' || value === true);
                    break;
                case 'null':
                    convertedValue = null;
                    break;
            }
            const parent = getNode(path.slice(0, -1));
            parent[path.at(-1)] = convertedValue;
            displayData();
        });
        if (valueType !== 'object' && valueType !== 'array') {
            controls.appendChild(typeSelect);
        }

        nodeWrapper.appendChild(controls);

        // 子要素のコンテナ
        if (valueType === 'object' || valueType === 'array') {
            const nestedContainer = document.createElement('div');
            nestedContainer.className = 'nested-container';
            displayData(value, nestedContainer, path, false);
            nodeWrapper.appendChild(nestedContainer);
        }

        // === イベントリスナー ===

        // トグル機能
        toggleIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            const nested = nodeWrapper.querySelector('.nested-container');
            if (nested) {
                nested.style.display = nested.style.display === 'none' ? 'block' : 'none';
                e.target.textContent = nested.style.display === 'none' ? '▶' : '▼';
            }
        });

        // インライン編集
        nodeWrapper.addEventListener('dblclick', (e) => {
            const target = e.target;
            const isKey = target.classList.contains('key');
            if (isKey || target.classList.contains('string') || target.classList.contains('number') || target.classList.contains('boolean') || target.classList.contains('null')) {
                e.stopPropagation();
                
                const path = JSON.parse(nodeWrapper.dataset.path);
                const parent = getNode(path.slice(0, -1));
                const key = path.at(-1);
                const originalValue = isKey ? key : parent[key];

                const input = document.createElement('input');
                input.className = 'inline-edit';
                input.value = originalValue;
                input.style.width = `${target.offsetWidth}px`;

                target.style.display = 'none';
                nodeContent.insertBefore(input, target.nextSibling);
                input.focus();

                const finishEdit = () => {
                    let newValue = input.value;
                    let parsedValue = newValue;
                    
                    if (!isKey) {
                        try {
                            parsedValue = JSON.parse(newValue);
                            if (parsedValue === null && newValue.toLowerCase() !== 'null') {
                                throw new Error('not a null');
                            }
                        } catch {
                            parsedValue = newValue;
                        }
                    }

                    if (isKey) {
                        if (newValue.trim() !== key) {
                            if (parent.hasOwnProperty(newValue)) {
                                // 同じキーがある場合のエラー処理
                                alert('エラー: キーは既に存在します');
                                displayData();
                                return;
                            }
                            parent[newValue] = parent[key];
                            delete parent[key];
                        }
                    } else {
                        parent[key] = parsedValue;
                    }
                    displayData();
                };

                input.addEventListener('blur', finishEdit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        finishEdit();
                    }
                });
            }
        });
        
        return nodeWrapper;
    }

    // === ユーティリティ関数 ===
    function getNode(path, data = currentData) {
        let node = data;
        for (let key of path) {
            if (node === undefined || node === null) return undefined;
            if (typeof node !== 'object') return undefined;
            node = node[key];
        }
        return node;
    }

    // === 検索機能 ===
    searchBox.addEventListener('input', () => {
        const query = searchBox.value.toLowerCase();
        document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
        if (query) {
            findAndHighlight(query, currentData, treeView, []);
        }
    });

    function findAndHighlight(query, data, parentEl, path) {
        if (typeof data !== 'object' || data === null) return;
        Object.entries(data).forEach(([key, value], index) => {
            const currentPath = [...path, key];
            const nodeWrapper = parentEl.querySelector(`[data-path='${JSON.stringify(currentPath)}']`);
            if (!nodeWrapper) return;

            // キーをハイライト
            const keyEl = nodeWrapper.querySelector('.key');
            if (keyEl && String(key).toLowerCase().includes(query)) {
                keyEl.innerHTML = String(key).replace(new RegExp(query, 'gi'), `<span class="search-highlight">$&</span>`);
            } else if (keyEl) {
                 keyEl.innerHTML = String(key); // マッチしない場合は元に戻す
            }

            // 値をハイライト
            const valueEl = nodeWrapper.querySelector('.string, .number, .boolean, .null');
            if (valueEl) {
                const valueText = String(value);
                if (valueText.toLowerCase().includes(query)) {
                    valueEl.innerHTML = valueText.replace(new RegExp(query, 'gi'), `<span class="search-highlight">$&</span>`);
                } else {
                    valueEl.innerHTML = valueText; // マッチしない場合は元に戻す
                }
            }

            if (typeof value === 'object' && value !== null) {
                const nestedEl = nodeWrapper.querySelector('.nested-container');
                if (nestedEl) findAndHighlight(query, value, nestedEl, currentPath);
            }
        });
    }

    // === 整形ボタン ===
    formatBtn.addEventListener('click', () => {
        try {
            const data = editorMode === 'tree' ? currentData : JSON.parse(textEditor.value);
            const formatted = JSON.stringify(data, null, 2);
            textEditor.value = formatted;
        } catch (e) {
            alert('JSONの整形に失敗しました。');
        }
    });
});
</script>

</body>
</html>