<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Enhanced Web CLI - é«˜æ©Ÿèƒ½ã‚¿ãƒ¼ãƒŸãƒŠãƒ«</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #00ff88;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: background 0.5s ease;
    }

    #header {
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      padding: 10px 15px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #header h1 {
      margin: 0;
      font-size: 1.2em;
      color: #00ff88;
      text-shadow: 0 0 10px #00ff88;
    }

    #controls {
      display: flex;
      gap: 10px;
    }

    #controls button {
      padding: 5px 10px;
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid #00ff88;
      border-radius: 5px;
      color: #00ff88;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9em;
    }

    #controls button:hover {
      background: rgba(0, 255, 136, 0.2);
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }

    #terminal {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.4;
      -webkit-user-select: text;
      user-select: text;
    }

    .line {
      margin: 3px 0;
      display: flex;
      align-items: flex-start;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-5px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .output {
      flex: 1;
      padding: 2px 6px;
      border-radius: 3px;
      word-wrap: break-word;
    }

    .copyBtn {
      margin-left: 8px;
      cursor: pointer;
      opacity: 0.4;
      transition: opacity 0.2s;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 0.8em;
    }

    .copyBtn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
    }

    .help-highlight {
      background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
      color: #fff;
      padding: 4px 8px;
      border-radius: 5px;
      margin: 2px 0;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .prompt-line {
      display: flex;
      align-items: center;
      padding: 12px 15px;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      border-top: 1px solid #444;
      position: relative;
    }

    #promptLabel {
      color: #ff79c6;
      margin-right: 10px;
      white-space: nowrap;
      user-select: none;
      font-weight: bold;
      min-width: 200px;
      text-shadow: 0 0 5px #ff79c6;
    }

    #input {
      flex: 1;
      font-size: 1em;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(0, 255, 136, 0.3);
      border-radius: 5px;
      outline: none;
      color: #00ff88;
      font-family: inherit;
      padding: 8px 12px;
      transition: all 0.3s;
    }

    #input:focus {
      border-color: #00ff88;
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }

    #suggestions {
      position: absolute;
      bottom: 100%;
      left: 215px;
      right: 15px;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid #444;
      border-radius: 5px;
      max-height: 150px;
      overflow-y: auto;
      display: none;
    }

    .suggestion {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #333;
      transition: background 0.2s;
    }

    .suggestion:hover,
    .suggestion.selected {
      background: rgba(0, 255, 136, 0.1);
    }

    .suggestion:last-child {
      border-bottom: none;
    }

    .error {
      color: #ff5555;
    }

    .success {
      color: #50fa7b;
    }

    .info {
      color: #8be9fd;
    }

    .warning {
      color: #f1fa8c;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
      padding: 20px;
      z-index: 1000;
    }

    .hidden {
      display: none;
    }

    .overlay-content {
      background: linear-gradient(135deg, #2d2d2d, #1a1a2e);
      color: #f8f8f2;
      padding: 25px;
      border-radius: 10px;
      border: 1px solid #444;
      max-width: 90%;
      width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .overlay-content h2 {
      color: #00ff88;
      text-align: center;
      margin-top: 0;
      text-shadow: 0 0 10px #00ff88;
    }

    .overlay-content ul {
      list-style: none;
      padding: 0;
    }

    .overlay-content li {
      margin-bottom: 8px;
      padding: 5px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 5px;
      border-left: 3px solid #00ff88;
    }

    .overlay-content code {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 5px;
      border-radius: 3px;
      color: #ff79c6;
    }

    .overlay-content button {
      margin: 15px 5px 5px;
      padding: 10px 16px;
      background: linear-gradient(45deg, #444, #666);
      border: none;
      border-radius: 5px;
      color: #eee;
      cursor: pointer;
      transition: all 0.3s;
    }

    .overlay-content button:hover {
      background: linear-gradient(45deg, #555, #777);
      transform: translateY(-2px);
    }

    #editorOverlay textarea {
      width: 100%;
      height: 350px;
      background: rgba(0, 0, 0, 0.5);
      color: #f8f8f2;
      border: 1px solid #444;
      border-radius: 5px;
      outline: none;
      font-family: inherit;
      font-size: 1em;
      padding: 12px;
      resize: vertical;
      transition: border-color 0.3s;
    }

    #editorOverlay textarea:focus {
      border-color: #00ff88;
    }

    .btnGroup {
      margin-top: 12px;
      text-align: right;
    }

    .btnGroup button {
      margin-left: 10px;
    }

    .status-bar {
      background: rgba(0, 0, 0, 0.3);
      padding: 5px 15px;
      font-size: 0.9em;
      color: #888;
      border-top: 1px solid #333;
    }

    .file-icon {
      display: inline-block;
      width: 16px;
      text-align: center;
      margin-right: 5px;
    }

    .clickable-file {
      cursor: pointer;
      color: #8be9fd;
      text-decoration: underline;
      text-underline-offset: 3px;
      text-decoration-thickness: 1px;
      transition: color 0.2s;
    }

    .clickable-file:hover {
      color: #f1fa8c;
    }

    .ls-file-info {
      display: inline-block;
      width: 100px;
      color: #888;
    }

    .ls-date-info {
      display: inline-block;
      width: 200px;
      color: #888;
    }

    .ls-permissions {
      display: inline-block;
      width: 100px;
      color: #50fa7b;
    }
    
    .file-entry-container {
      display: flex;
      align-items: center;
      flex: 1;
    }

    .file-name-input {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ff88;
      color: #fff;
      font-family: inherit;
      font-size: 1em;
      padding: 2px 6px;
      border-radius: 3px;
      outline: none;
      flex: 1;
    }

    /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 136, 0.3);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 255, 136, 0.5);
    }
  </style>
</head>

<body>
  <div id="header">
    <h1>ğŸš€ Enhanced Web CLI</h1>
    <div id="controls">
      <button id="helpBtn" title="ãƒ˜ãƒ«ãƒ—">â“ Help</button>
      <button id="themeBtn" title="ãƒ†ãƒ¼ãƒåˆ‡æ›¿">ğŸ¨ Theme</button>
      <button id="exportZipBtn" title="ZIPã«ã¾ã¨ã‚ã¦ä¿å­˜">ğŸ“¥ ZIP Export</button>
      <button id="importZipBtn" title="ZIPã‹ã‚‰èª­ã¿è¾¼ã¿">ğŸ“¤ ZIP Import</button>
      <button id="clearBtn" title="ç”»é¢ã‚¯ãƒªã‚¢">ğŸ—‘ï¸ Clear</button>
    </div>
  </div>
  <div id="terminal" aria-live="polite" aria-atomic="false"></div>
  <div class="prompt-line" role="region" aria-label="ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›">
    <span id="promptLabel">user@webcli:/ $</span>
    <input id="input" autocomplete="off" placeholder="ã‚³ãƒãƒ³ãƒ‰ã‚’å…¥åŠ›... (Tab ã§è£œå®Œ)" />
    <div id="suggestions"></div>
  </div>
  <div class="status-bar">
    <span id="statusText">Ready</span> | Files: <span id="fileCount">0</span> | Last: <span id="lastCommand">-</span>
  </div>
  <div id="cmdOverlay" class="overlay hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="overlay-content">
      <h2 id="helpTitle">ğŸ“š ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§</h2>
      <ul id="helpList">
        <li><code>help</code> : ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§ã¨èª¬æ˜ã‚’è¡¨ç¤º</li>
        <li><code>pwd</code> : ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªè¡¨ç¤º</li>
        <li><code>ls [-l] [path]</code> : ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä¸€è¦§ã€‚-lã§è©³ç´°è¡¨ç¤º</li>
        <li><code>cd &lt;dir&gt;</code> : ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç§»å‹•</li>
        <li><code>mkdir &lt;dir&gt;</code> : ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ</li>
        <li><code>touch &lt;file&gt;</code> : ç©ºãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ</li>
        <li><code>cat &lt;file&gt;</code> : ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹è¡¨ç¤º</li>
        <li><code>write &lt;file&gt; text</code> : ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¸Šæ›¸ã</li>
        <li><code>append &lt;file&gt; text</code> : ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½è¨˜</li>
        <li><code>rm &lt;file/dir&gt;</code> : ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå‰Šé™¤</li>
        <li><code>mv &lt;from&gt; &lt;to&gt;</code> : ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç§»å‹•ãƒ»ãƒªãƒãƒ¼ãƒ </li>
        <li><code>cp &lt;from&gt; &lt;to&gt;</code> : ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚³ãƒ”ãƒ¼</li>
        <li><code>find &lt;name&gt;</code> : ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ¤œç´¢</li>
        <li><code>tree [path]</code> : ãƒ•ã‚¡ã‚¤ãƒ«ãƒ„ãƒªãƒ¼è¡¨ç¤º</li>
        <li><code>clear</code> : ç”»é¢ã‚¯ãƒªã‚¢</li>
        <li><code>edit &lt;file&gt;</code> : ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿èµ·å‹•</li>
        <li><code>history</code> : ã‚³ãƒãƒ³ãƒ‰å±¥æ­´è¡¨ç¤º</li>
        <li><code>export</code> : ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’JSONã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</li>
        <li><code>import</code> : JSONã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</li>
        <li><code>reset</code> : ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ</li>
      </ul>
      <div style="text-align: center;">
        <button id="closeOverlay">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>
  <div id="editorOverlay" class="overlay hidden" role="dialog" aria-modal="true" aria-labelledby="editTitle">
    <div class="overlay-content">
      <h2 id="editTitle">ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ç·¨é›†</h2>
      <textarea id="editorText" aria-label="ãƒ•ã‚¡ã‚¤ãƒ«ç·¨é›†ã‚¨ãƒªã‚¢" placeholder="ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’å…¥åŠ›..."></textarea>
      <div class="btnGroup">
        <button id="btnSave">ğŸ’¾ ä¿å­˜</button>
        <button id="btnCancel">âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      </div>
    </div>
  </div>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const terminal = document.getElementById("terminal");
      const input = document.getElementById("input");
      const promptLabel = document.getElementById("promptLabel");
      const suggestions = document.getElementById("suggestions");
      const helpBtn = document.getElementById("helpBtn");
      const themeBtn = document.getElementById("themeBtn");
      const exportZipBtn = document.getElementById("exportZipBtn");
      const importZipBtn = document.getElementById("importZipBtn");
      const clearBtn = document.getElementById("clearBtn");
      const overlay = document.getElementById("cmdOverlay");
      const closeBtn = document.getElementById("closeOverlay");
      const editorOverlay = document.getElementById("editorOverlay");
      const editorText = document.getElementById("editorText");
      const btnSave = document.getElementById("btnSave");
      const btnCancel = document.getElementById("btnCancel");
      const statusText = document.getElementById("statusText");
      const fileCount = document.getElementById("fileCount");
      const lastCommand = document.getElementById("lastCommand");

      // ãƒ†ãƒ¼ãƒè¨­å®š
      const themes = {
        default: {
          bg: 'linear-gradient(135deg, #1a1a2e, #16213e)',
          text: '#00ff88',
          accent: '#ff79c6',
          secondary: '#8be9fd'
        },
        matrix: {
          bg: 'linear-gradient(135deg, #000000, #0d1b0d)',
          text: '#00ff00',
          accent: '#ffffff',
          secondary: '#ffffff'
        },
        cyberpunk: {
          bg: 'linear-gradient(135deg, #0f0f2e, #2e0f2e)',
          text: '#ff00ff',
          accent: '#00ffff',
          secondary: '#8be9fd'
        }
      };

      let currentTheme = 0;
      const themeKeys = Object.keys(themes);

      function applyTheme() {
        const theme = themes[themeKeys[currentTheme]];
        document.body.style.background = theme.bg;
        document.body.style.color = theme.text;
        document.documentElement.style.setProperty('--accent-color', theme.accent);
        document.documentElement.style.setProperty('--secondary-color', theme.secondary);
      }

      // VFSæ§‹é€ ä½“ï¼†åˆæœŸåŒ–
      let vfs = JSON.parse(localStorage.getItem("VFS")) || {
        type: "dir",
        children: {
          "welcome.txt": {
            type: "file",
            content: "Enhanced Web CLI ã¸ã‚ˆã†ã“ãï¼\n\nã“ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ã¯ä»¥ä¸‹ã®ã“ã¨ãŒã§ãã¾ã™:\n- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ“ä½œ\n- ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿\n- æ¤œç´¢ãƒ»ã‚³ãƒ”ãƒ¼ãƒ»ç§»å‹•\n- ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ»ã‚¤ãƒ³ãƒãƒ¼ãƒˆ\n\n'help' ã‚³ãƒãƒ³ãƒ‰ã§è©³ç´°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚",
            ctime: new Date().toISOString(),
            mtime: new Date().toISOString()
          },
          "docs": {
            type: "dir",
            children: {
              "readme.md": {
                type: "file",
                content: "# Enhanced Web CLI\n\né«˜æ©Ÿèƒ½ãªWebãƒ™ãƒ¼ã‚¹ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ã™ã€‚\n\n## ç‰¹å¾´\n- ç›´æ„Ÿçš„ãªUI\n- è±Šå¯Œãªã‚³ãƒãƒ³ãƒ‰\n- ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†\n- ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–",
                ctime: new Date().toISOString(),
                mtime: new Date().toISOString()
              }
            }
          }
        }
      };
      let cwd = []; // ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª ãƒ‘ã‚¹é…åˆ—
      const history = JSON.parse(localStorage.getItem("CLI_HISTORY")) || [];
      let historyIndex = history.length;
      let completionList = [];
      let completionIndex = -1;
      let selectedSuggestion = -1;

      function saveVFS() {
        localStorage.setItem("VFS", JSON.stringify(vfs));
        updateFileCount();
      }

      function saveHistory() {
        localStorage.setItem("CLI_HISTORY", JSON.stringify(history.slice(-50))); // æœ€æ–°50ä»¶ã®ã¿ä¿å­˜
      }

      function getNode(path) {
        let node = vfs;
        for (let p of path) {
          if (node.type === "dir" && node.children[p]) {
            node = node.children[p];
          } else {
            return null;
          }
        }
        return node;
      }

      function ensureDir(node) {
        return node && node.type === "dir";
      }

      function getFileIcon(file) {
        if (file.type === "dir") return "ğŸ“";
        const name = file.name || "";
        if (name.endsWith(".txt")) return "ğŸ“„";
        if (name.endsWith(".md")) return "ğŸ“";
        if (name.endsWith(".js")) return "ğŸ“œ";
        if (name.endsWith(".html")) return "ğŸŒ";
        if (name.endsWith(".css")) return "ğŸ¨";
        if (name.endsWith(".json")) return "ğŸ”§";
        return "ğŸ“„";
      }

      function fmtDate(d) {
        if (!(d instanceof Date)) d = new Date(d);
        return d.toLocaleString('ja-JP');
      }

      function fmtSize(n) {
        if (n < 1024) return n + "B";
        if (n < 1024 * 1024) return (n / 1024).toFixed(1) + "KB";
        if (n < 1024 * 1024 * 1024) return (n / 1024 / 1024).toFixed(1) + "MB";
        return (n / 1024 / 1024 / 1024).toFixed(1) + "GB";
      }

      function fileSize(file) {
        if (typeof file.content === "string") {
          return new TextEncoder().encode(file.content).length;
        }
        return 0;
      }

      function updatePrompt() {
        const pathStr = "/" + (cwd.length === 0 ? "" : cwd.join("/"));
        promptLabel.textContent = `user@webcli:${pathStr} $`;
      }

      function updateFileCount() {
        let count = 0;
        function countFiles(node) {
          if (node.type === "file") count++;
          if (node.type === "dir") {
            Object.values(node.children).forEach(countFiles);
          }
        }
        countFiles(vfs);
        fileCount.textContent = count;
      }

      function updateStatus(message) {
        statusText.textContent = message;
        setTimeout(() => statusText.textContent = "Ready", 3000);
      }

      // å‡ºåŠ›é–¢æ•°
      function print(text, cls = "", highlight = false) {
        const line = document.createElement("div");
        line.className = "line";

        const span = document.createElement("span");
        span.className = "output";
        if (cls) span.classList.add(cls);
        if (highlight) span.classList.add("help-highlight");

        span.innerHTML = text.replace(/\n/g, '<br>').replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');

        const copyBtn = document.createElement("span");
        copyBtn.innerHTML = "ğŸ“‹";
        copyBtn.className = "copyBtn";
        copyBtn.title = "ã‚³ãƒ”ãƒ¼";
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(text);
          copyBtn.innerHTML = "âœ…";
          setTimeout(() => copyBtn.innerHTML = "ğŸ“‹", 1000);
        };

        line.appendChild(span);
        if (text.trim()) line.appendChild(copyBtn);

        terminal.appendChild(line);
        terminal.scrollTop = terminal.scrollHeight;
      }
      
      // ãƒ•ã‚¡ã‚¤ãƒ«åè¡¨ç¤ºã¨ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ç·¨é›†
      function printFileEntry(icon, name, isFile) {
        const line = document.createElement("div");
        line.className = "line";

        const container = document.createElement("span");
        container.className = "output file-entry-container";

        const iconSpan = document.createElement("span");
        iconSpan.className = "file-icon";
        iconSpan.textContent = icon;

        const nameSpan = document.createElement("span");
        nameSpan.className = "file-name-display";
        nameSpan.textContent = name + (isFile ? "" : "/");

        const copyBtn = document.createElement("span");
        copyBtn.innerHTML = "ğŸ“‹";
        copyBtn.className = "copyBtn";
        copyBtn.title = "ãƒ‘ã‚¹ã‚’ã‚³ãƒ”ãƒ¼";
        copyBtn.onclick = () => {
          const fullPath = "/" + [...cwd, name].join("/");
          navigator.clipboard.writeText(fullPath);
          copyBtn.innerHTML = "âœ…";
          setTimeout(() => copyBtn.innerHTML = "ğŸ“‹", 1000);
        };

        container.appendChild(iconSpan);
        container.appendChild(nameSpan);

        if (isFile) {
          nameSpan.classList.add("clickable-file");
          nameSpan.title = "ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†";
          nameSpan.dataset.filename = name;
        } else {
          nameSpan.title = "ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§åå‰å¤‰æ›´";
          nameSpan.classList.add("clickable-dir");
          nameSpan.dataset.filename = name;
        }

        line.appendChild(container);
        line.appendChild(copyBtn);
        terminal.appendChild(line);
      }
      
      function enableRename(nameSpan, oldName) {
        const line = nameSpan.closest('.line');
        const iconSpan = line.querySelector('.file-icon');
        const inputField = document.createElement('input');
        inputField.className = 'file-name-input';
        inputField.type = 'text';
        inputField.value = oldName;
        inputField.style.width = `${oldName.length + 2}ch`;

        nameSpan.style.display = 'none';
        iconSpan.after(inputField);
        inputField.focus();
        inputField.select();

        const finishRename = (newName) => {
          if (!newName || newName.trim() === oldName || newName.trim() === '') {
            print("å¤‰æ›´ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚", "info");
          } else {
            const node = getNode(cwd);
            if (node.children[newName.trim()]) {
              print(`ã‚¨ãƒ©ãƒ¼: '${newName.trim()}' ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™`, "error");
            } else {
              node.children[newName.trim()] = node.children[oldName];
              delete node.children[oldName];
              saveVFS();
              print(`âœ… '${oldName}' ã‚’ '${newName.trim()}' ã«å¤‰æ›´ã—ã¾ã—ãŸ`, "success");
              updateStatus("ãƒ•ã‚¡ã‚¤ãƒ«åå¤‰æ›´å®Œäº†");
            }
          }
          // å…ƒã®è¡¨ç¤ºã«æˆ»ã™
          inputField.remove();
          nameSpan.style.display = 'block';
        };

        inputField.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            finishRename(inputField.value);
          } else if (e.key === 'Escape') {
            e.preventDefault();
            finishRename('');
          }
        });

        inputField.addEventListener('blur', () => {
          finishRename(inputField.value);
        });
      }

      // ãƒ‘ã‚¹è§£æ±º
      function resolvePath(pathStr) {
        if (!pathStr) return [...cwd];
        let parts = pathStr.split("/").filter(p => p !== "");
        let res = pathStr.startsWith("/") ? [] : [...cwd];

        for (let p of parts) {
          if (p === ".") continue;
          else if (p === "..") res.pop();
          else res.push(p);
        }
        return res;
      }

      // ãƒ„ãƒªãƒ¼è¡¨ç¤º
      function showTree(node, prefix = "", name = "", path = []) {
        let out = "";
        if (name) {
          const icon = getFileIcon(node);
          out += prefix + "â”œâ”€â”€ " + icon + " " + name + (node.type === "dir" ? "/" : "") + "\n";
        }

        if (node.type === "dir") {
          const entries = Object.entries(node.children);
          entries.forEach(([key, child], index) => {
            const isLast = index === entries.length - 1;
            const newPrefix = prefix + (name ? (isLast ? "    " : "â”‚   ") : "");
            out += showTree(child, newPrefix, key, [...path, key]);
          });
        }
        return out;
      }

      // ls -l è©³ç´°è¡¨ç¤ºç”¨é–¢æ•°
      function listDetailedDir(node) {
        const entries = Object.entries(node.children).sort(([a, nodeA], [b, nodeB]) => {
          if (nodeA.type !== nodeB.type) {
            return nodeA.type === "dir" ? -1 : 1;
          }
          return a.localeCompare(b);
        });

        entries.forEach(([key, item]) => {
          const line = document.createElement("div");
          line.className = "line";

          const typeChar = item.type === "dir" ? "d" : "-";
          const perms = "rwxrwxrwx";
          const size = item.type === "file" ? fmtSize(fileSize(item)) : "-";
          const mtime = item.mtime ? fmtDate(item.mtime) : "-";
          const icon = getFileIcon(item);

          const permsSpan = document.createElement("span");
          permsSpan.className = "output ls-permissions";
          permsSpan.textContent = typeChar + perms;

          const sizeSpan = document.createElement("span");
          sizeSpan.className = "output ls-file-info";
          sizeSpan.textContent = size.toString().padStart(8);

          const dateSpan = document.createElement("span");
          dateSpan.className = "output ls-date-info";
          dateSpan.textContent = mtime;
          
          const nameSpan = document.createElement("span");
          nameSpan.className = "file-entry-container";
          nameSpan.innerHTML = `<span class="file-icon">${icon}</span><span class="file-name-display">${key}${item.type === "dir" ? "/" : ""}</span>`;
          nameSpan.dataset.filename = key;
          
          if(item.type === "file"){
            nameSpan.title = "ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†";
            nameSpan.classList.add("clickable-file");
          } else {
            nameSpan.title = "ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§åå‰å¤‰æ›´";
            nameSpan.classList.add("clickable-dir");
          }
          
          line.appendChild(permsSpan);
          line.appendChild(sizeSpan);
          line.appendChild(dateSpan);
          line.appendChild(nameSpan);

          terminal.appendChild(line);
        });
      }

      // ãƒ•ã‚¡ã‚¤ãƒ«æ¤œç´¢
      function findFiles(searchTerm, node = vfs, path = []) {
        let results = [];
        if (node.type === "dir") {
          for (let [name, child] of Object.entries(node.children)) {
            const fullPath = "/" + [...path, name].join("/");
            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
              results.push({
                path: fullPath,
                type: child.type,
                node: child
              });
            }
            if (child.type === "dir") {
              results.push(...findFiles(searchTerm, child, [...path, name]));
            }
          }
        }
        return results;
      }

      // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚³ãƒ”ãƒ¼ï¼ˆå†å¸°ï¼‰
      function copyDir(sourceNode) {
        if (sourceNode.type === "file") {
          return {
            type: "file",
            content: sourceNode.content,
            ctime: new Date().toISOString(),
            mtime: sourceNode.mtime
          };
        } else {
          const newDir = {
            type: "dir",
            children: {}
          };
          for (let [name, child] of Object.entries(sourceNode.children)) {
            newDir.children[name] = copyDir(child);
          }
          return newDir;
        }
      }

      // ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§
      const commands = {
        help: "ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§ã¨èª¬æ˜ã‚’è¡¨ç¤º",
        pwd: "ç¾åœ¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªè¡¨ç¤º",
        ls: "ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä¸€è¦§ã€‚-lã§è©³ç´°è¡¨ç¤º",
        cd: "ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç§»å‹•",
        mkdir: "ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ",
        touch: "ç©ºãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ",
        cat: "ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹è¡¨ç¤º",
        write: "ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¸Šæ›¸ã",
        append: "ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½è¨˜",
        rm: "ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå‰Šé™¤",
        mv: "ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç§»å‹•ãƒ»ãƒªãƒãƒ¼ãƒ ",
        cp: "ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚³ãƒ”ãƒ¼",
        find: "ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ¤œç´¢",
        tree: "ãƒ•ã‚¡ã‚¤ãƒ«ãƒ„ãƒªãƒ¼è¡¨ç¤º",
        clear: "ç”»é¢ã‚¯ãƒªã‚¢",
        edit: "ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿èµ·å‹•",
        history: "ã‚³ãƒãƒ³ãƒ‰å±¥æ­´è¡¨ç¤º",
        export: "ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’JSONã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ",
        import: "JSONã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ",
        reset: "ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ"
      };

      // HELPè¡¨ç¤º
      function showHelp() {
        print("ğŸš€ Enhanced Web CLI - ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§", "info");
        print("=" .repeat(50), "info");

        Object.entries(commands).forEach(([cmd, desc]) => {
          print(`${cmd.padEnd(12)} : ${desc}`, "", true);
        });

        print("\nğŸ’¡ ãƒ’ãƒ³ãƒˆ:", "info");
        print("- Tab ã‚­ãƒ¼ã§è£œå®Œ", "success");
        print("- â†‘â†“ ã‚­ãƒ¼ã§å±¥æ­´", "success");
        print("- ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†ãƒ»åå‰å¤‰æ›´", "success");
      }

      // ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ/ç·¨é›†æ™‚ã®æ—¥ä»˜ä»˜ä¸
      function setFileDates(file, isNew) {
        const now = new Date().toISOString();
        if (isNew) {
          file.ctime = now;
          file.mtime = now;
        } else {
          file.mtime = now;
        }
      }

      // ã‚³ãƒãƒ³ãƒ‰å‡¦ç†
      function processCommand(line) {
        if (!line.trim()) return;

        print(`> ${line}`, "info");

        history.push(line);
        historyIndex = history.length;
        saveHistory();
        lastCommand.textContent = line.split(' ')[0];

        const args = line.trim().split(/\s+/);
        const cmd = args[0];
        const rest = args.slice(1);

        try {
          switch (cmd) {
            case "help":
              showHelp();
              updateStatus("ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ");
              break;

            case "pwd":
              print("/" + cwd.join("/"));
              updateStatus("ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è¡¨ç¤º");
              break;

            case "ls": {
              const node = getNode(cwd);
              if (!ensureDir(node)) {
                print("ã‚¨ãƒ©ãƒ¼: ä¸æ­£ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª", "error");
                break;
              }

              const isDetailed = rest.includes("-l");
              const entries = Object.entries(node.children).sort(([a, nodeA], [b, nodeB]) => {
                if (nodeA.type !== nodeB.type) {
                  return nodeA.type === "dir" ? -1 : 1;
                }
                return a.localeCompare(b);
              });

              if (isDetailed) {
                listDetailedDir(node);
              } else {
                entries.forEach(([name, child]) => {
                  const icon = getFileIcon(child);
                  printFileEntry(icon, name, child.type === "file");
                });
                if (entries.length === 0) {
                  print("ï¼ˆç©ºã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼‰", "warning");
                }
              }
              updateStatus(`${entries.length} å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¡¨ç¤º`);
              break;
            }

            case "cd": {
              if (rest.length === 0) {
                cwd = [];
                updatePrompt();
                print("ãƒ›ãƒ¼ãƒ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•ã—ã¾ã—ãŸ");
                break;
              }

              const path = resolvePath(rest[0]);
              const node = getNode(path);
              if (ensureDir(node)) {
                cwd = path;
                updatePrompt();
                print(`ç§»å‹•ã—ã¾ã—ãŸ: /${cwd.join("/")}`);
                updateStatus(`${rest[0]} ã«ç§»å‹•`);
              } else {
                print(`ã‚¨ãƒ©ãƒ¼: ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª '${rest[0]}' ãŒå­˜åœ¨ã—ã¾ã›ã‚“`, "error");
              }
              break;
            }

            case "mkdir": {
              if (rest.length === 0) {
                print("ã‚¨ãƒ©ãƒ¼: ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåãŒå¿…è¦ã§ã™", "error");
                break;
              }

              const node = getNode(cwd);
              if (!ensureDir(node)) {
                print("ã‚¨ãƒ©ãƒ¼: ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒç„¡åŠ¹ã§ã™", "error");
                break;
              }

              const dirName = rest[0];
              if (node.children[dirName]) {
                print(`ã‚¨ãƒ©ãƒ¼: '${dirName}' ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™`, "error");
                break;
              }

              node.children[dirName] = {
                type: "dir",
                children: {},
                ctime: new Date().toISOString(),
                mtime: new Date().toISOString()
              };
              saveVFS();
              print(`âœ… ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª '${dirName}' ã‚’ä½œæˆã—ã¾ã—ãŸ`, "success");
              updateStatus("ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆå®Œäº†");
              break;
            }

            case "touch": {
              if (rest.length === 0) {
                print("ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«åãŒå¿…è¦ã§ã™", "error");
                break;
              }

              const node = getNode(cwd);
              const fileName = rest[0];

              if (node.children[fileName]) {
                if (node.children[fileName].type === "file") {
                  setFileDates(node.children[fileName], false);
                  print(`ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ« '${fileName}' ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’æ›´æ–°ã—ã¾ã—ãŸ`, "success");
                } else {
                  print(`ã‚¨ãƒ©ãƒ¼: '${fileName}' ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™`, "error");
                }
                break;
              }

              const newFile = {
                type: "file",
                content: ""
              };
              setFileDates(newFile, true);
              node.children[fileName] = newFile;
              saveVFS();
              print(`âœ… ãƒ•ã‚¡ã‚¤ãƒ« '${fileName}' ã‚’ä½œæˆã—ã¾ã—ãŸ`, "success");
              updateStatus("ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆå®Œäº†");
              break;
            }

            case "cat": {
              if (rest.length === 0) {
                print("ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«åãŒå¿…è¦ã§ã™", "error");
                break;
              }

              const node = getNode(cwd);
              const file = node.children[rest[0]];

              if (file && file.type === "file") {
                if (file.content.trim()) {
                  print("ğŸ“„ " + file.content);
                } else {
                  print("ï¼ˆç©ºã®ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰", "warning");
                }
                updateStatus("ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’è¡¨ç¤º");
              } else {
                print(`ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ« '${rest[0]}' ãŒå­˜åœ¨ã—ã¾ã›ã‚“`, "error");
              }
              break;
            }

            case "write": {
              if (rest.length < 2) {
                print("ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«åã¨å†…å®¹ãŒå¿…è¦ã§ã™", "error");
                print("ä½¿ç”¨æ³•: write <ãƒ•ã‚¡ã‚¤ãƒ«å> <å†…å®¹>", "info");
                break;
              }

              const node = getNode(cwd);
              const fileName = rest[0];
              const content = rest.slice(1).join(" ");

              let targetFile = node.children[fileName];
              if (!targetFile) {
                targetFile = {
                  type: "file",
                  content: ""
                };
                setFileDates(targetFile, true);
                node.children[fileName] = targetFile;
              }

              if (targetFile.type !== "file") {
                print(`ã‚¨ãƒ©ãƒ¼: '${fileName}' ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™`, "error");
                break;
              }

              targetFile.content = content;
              setFileDates(targetFile, false);
              saveVFS();
              print(`âœ… ãƒ•ã‚¡ã‚¤ãƒ« '${fileName}' ã«æ›¸ãè¾¼ã¿ã¾ã—ãŸ`, "success");
              updateStatus("ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿å®Œäº†");
              break;
            }

            case "append": {
              if (rest.length < 2) {
                print("ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«åã¨å†…å®¹ãŒå¿…è¦ã§ã™", "error");
                print("ä½¿ç”¨æ³•: append <ãƒ•ã‚¡ã‚¤ãƒ«å> <å†…å®¹>", "info");
                break;
              }

              const node = getNode(cwd);
              const fileName = rest[0];
              const content = rest.slice(1).join(" ");

              let targetFile = node.children[fileName];
              if (!targetFile) {
                targetFile = {
                  type: "file",
                  content: ""
                };
                setFileDates(targetFile, true);
                node.children[fileName] = targetFile;
              }

              if (targetFile.type !== "file") {
                print(`ã‚¨ãƒ©ãƒ¼: '${fileName}' ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™`, "error");
                break;
              }

              targetFile.content += (targetFile.content ? "\n" : "") + content;
              setFileDates(targetFile, false);
              saveVFS();
              print(`âœ… ãƒ•ã‚¡ã‚¤ãƒ« '${fileName}' ã«è¿½è¨˜ã—ã¾ã—ãŸ`, "success");
              updateStatus("ãƒ•ã‚¡ã‚¤ãƒ«è¿½è¨˜å®Œäº†");
              break;
            }

            case "rm": {
              if (rest.length === 0) {
                print("ã‚¨ãƒ©ãƒ¼: å‰Šé™¤å¯¾è±¡ã‚’æŒ‡å®šã—ã¦ãã ã•ã„", "error");
                break;
              }

              const node = getNode(cwd);
              const target = rest[0];

              if (!node.children[target]) {
                print(`ã‚¨ãƒ©ãƒ¼: '${target}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, "error");
                break;
              }

              if (node.children[target].type === "dir") {
                const dirNode = node.children[target];
                const itemCount = Object.keys(dirNode.children).length;
                if (itemCount > 0) {
                  print(`âš ï¸ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª '${target}' ã«ã¯ ${itemCount} å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚Šã¾ã™`, "warning");
                  print("æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ [Y/N]");

                  const confirmed = confirm(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª '${target}' ã¨ãã®ä¸­èº«ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`);
                  if (!confirmed) {
                    print("å‰Šé™¤ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ");
                    break;
                  }
                }
              }

              delete node.children[target];
              saveVFS();
              print(`âœ… '${target}' ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, "success");
              updateStatus("å‰Šé™¤å®Œäº†");
              break;
            }

            case "mv": {
              if (rest.length < 2) {
                print("ã‚¨ãƒ©ãƒ¼: ç§»å‹•å…ƒã¨ç§»å‹•å…ˆãŒå¿…è¦ã§ã™", "error");
                print("ä½¿ç”¨æ³•: mv <ç§»å‹•å…ƒ> <ç§»å‹•å…ˆ>", "info");
                break;
              }

              const node = getNode(cwd);
              const from = rest[0];
              const to = rest[1];

              if (!node.children[from]) {
                print(`ã‚¨ãƒ©ãƒ¼: '${from}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, "error");
                break;
              }

              if (node.children[to]) {
                print(`ã‚¨ãƒ©ãƒ¼: '${to}' ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™`, "error");
                break;
              }

              node.children[to] = node.children[from];
              delete node.children[from];
              saveVFS();
              print(`âœ… '${from}' ã‚’ '${to}' ã«ç§»å‹•ã—ã¾ã—ãŸ`, "success");
              updateStatus("ç§»å‹•å®Œäº†");
              break;
            }

            case "cp": {
              if (rest.length < 2) {
                print("ã‚¨ãƒ©ãƒ¼: ã‚³ãƒ”ãƒ¼å…ƒã¨ã‚³ãƒ”ãƒ¼å…ˆãŒå¿…è¦ã§ã™", "error");
                print("ä½¿ç”¨æ³•: cp <ã‚³ãƒ”ãƒ¼å…ƒ> <ã‚³ãƒ”ãƒ¼å…ˆ>", "info");
                break;
              }

              const node = getNode(cwd);
              const from = rest[0];
              const to = rest[1];

              if (!node.children[from]) {
                print(`ã‚¨ãƒ©ãƒ¼: '${from}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, "error");
                break;
              }

              if (node.children[to]) {
                print(`ã‚¨ãƒ©ãƒ¼: '${to}' ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™`, "error");
                break;
              }

              node.children[to] = copyDir(node.children[from]);
              saveVFS();
              print(`âœ… '${from}' ã‚’ '${to}' ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ`, "success");
              updateStatus("ã‚³ãƒ”ãƒ¼å®Œäº†");
              break;
            }

            case "find": {
              if (rest.length === 0) {
                print("ã‚¨ãƒ©ãƒ¼: æ¤œç´¢èªãŒå¿…è¦ã§ã™", "error");
                print("ä½¿ç”¨æ³•: find <æ¤œç´¢èª>", "info");
                break;
              }

              const searchTerm = rest[0];
              const results = findFiles(searchTerm);

              if (results.length === 0) {
                print(`'${searchTerm}' ã«ãƒãƒƒãƒã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ`, "warning");
              } else {
                print(`ğŸ” '${searchTerm}' ã®æ¤œç´¢çµæœ (${results.length}ä»¶):`, "info");
                results.forEach(result => {
                  const icon = getFileIcon(result.node);
                  print(`${icon} ${result.path} (${result.type})`);
                });
              }
              updateStatus(`æ¤œç´¢å®Œäº†: ${results.length}ä»¶`);
              break;
            }

            case "tree": {
              const path = rest[0] ? resolvePath(rest[0]) : cwd;
              const node = getNode(path);

              if (!node) {
                print("ã‚¨ãƒ©ãƒ¼: ãƒ‘ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "error");
                break;
              }

              const pathStr = "/" + path.join("/");
              print(`ğŸ“ ${pathStr}`, "info");
              const tree = showTree(node);
              if (tree) {
                print(tree);
              } else {
                print("â””â”€â”€ ï¼ˆç©ºï¼‰");
              }
              updateStatus("ãƒ„ãƒªãƒ¼è¡¨ç¤ºå®Œäº†");
              break;
            }

            case "clear":
              terminal.innerHTML = "";
              updateStatus("ç”»é¢ã‚’ã‚¯ãƒªã‚¢");
              break;

            case "edit": {
              if (rest.length === 0) {
                print("ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŒ‡å®šã—ã¦ãã ã•ã„", "error");
                break;
              }
              const fileName = rest[0];
              const node = getNode(cwd);
              let file = node.children[fileName];

              if (!file) {
                const create = confirm(`ãƒ•ã‚¡ã‚¤ãƒ« '${fileName}' ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚æ–°ã—ãä½œæˆã—ã¾ã™ã‹ï¼Ÿ`);
                if (!create) {
                  print("ç·¨é›†ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ");
                  break;
                }
                file = {
                  type: "file",
                  content: ""
                };
                setFileDates(file, true);
                node.children[fileName] = file;
              }

              if (file.type !== "file") {
                print(`ã‚¨ãƒ©ãƒ¼: '${fileName}' ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™`, "error");
                break;
              }

              openEditor(fileName, file.content);
              break;
            }

            case "history": {
              if (history.length === 0) {
                print("å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“", "warning");
              } else {
                print("ğŸ“š ã‚³ãƒãƒ³ãƒ‰å±¥æ­´:", "info");
                history.slice(-20).forEach((cmd, i) => {
                  const num = (history.length - 20 + i + 1).toString().padStart(3);
                  print(`${num}: ${cmd}`);
                });
              }
              updateStatus(`å±¥æ­´è¡¨ç¤º: ${history.length}ä»¶`);
              break;
            }

            case "export": {
              const data = JSON.stringify(vfs, null, 2);
              const blob = new Blob([data], {
                type: "application/json"
              });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "filesystem_export.json";
              a.click();
              URL.revokeObjectURL(url);
              print("âœ… ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ", "success");
              updateStatus("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†");
              break;
            }

            case "import": {
              const fileInput = document.createElement("input");
              fileInput.type = "file";
              fileInput.accept = ".json";
              fileInput.style.display = 'none';
              document.body.appendChild(fileInput);

              fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                  const reader = new FileReader();
                  reader.onload = (e) => {
                    try {
                      const data = JSON.parse(e.target.result);
                      if (data.type === "dir" && data.children) {
                        vfs = data;
                        cwd = [];
                        updatePrompt();
                        saveVFS();
                        print("âœ… ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ", "success");
                        updateStatus("ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†");
                      } else {
                        print("ã‚¨ãƒ©ãƒ¼: ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™", "error");
                      }
                    } catch (err) {
                      print("ã‚¨ãƒ©ãƒ¼: JSONã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ", "error");
                    }
                  };
                  reader.readAsText(file);
                }
                document.body.removeChild(fileInput);
              };
              fileInput.click();
              break;
            }

            case "reset": {
              const confirmed = confirm("ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚");
              if (confirmed) {
                vfs = {
                  type: "dir",
                  children: {}
                };
                cwd = [];
                updatePrompt();
                saveVFS();
                localStorage.removeItem("CLI_HISTORY");
                terminal.innerHTML = "";
                print("ğŸ”„ ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ", "success");
                print("=== Enhanced Web CLI - æ–°ã—ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ ===", "info");
                updateStatus("ãƒªã‚»ãƒƒãƒˆå®Œäº†");
              }
              break;
            }

            default:
              print(`æœªçŸ¥ã®ã‚³ãƒãƒ³ãƒ‰: ${cmd}`, "error");
              print("'help' ã§ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§ã‚’ç¢ºèªã—ã¦ãã ã•ã„", "info");
          }
        } catch (error) {
          print(`ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`, "error");
          console.error("Command execution error:", error);
        }
      }

      // ã‚¨ãƒ‡ã‚£ã‚¿ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç®¡ç†
      let currentEditFile = null;

      function openEditor(filename, content) {
        currentEditFile = filename;
        editorText.value = content;
        editorOverlay.classList.remove("hidden");
        editorText.focus();
      }

      function closeEditor() {
        editorOverlay.classList.add("hidden");
        currentEditFile = null;
        input.focus();
      }

      // ZIPå‡¦ç†
      async function exportZip() {
        print("ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’ä½œæˆä¸­...", "info");
        const zip = new JSZip();

        function addFilesToZip(node, path) {
          if (node.type === "file") {
            zip.file(path, node.content);
          } else if (node.type === "dir") {
            for (const [name, child] of Object.entries(node.children)) {
              addFilesToZip(child, path ? `${path}/${name}` : name);
            }
          }
        }
        addFilesToZip(vfs, "");

        try {
          const content = await zip.generateAsync({ type: "blob" });
          const url = URL.createObjectURL(content);
          const a = document.createElement("a");
          a.href = url;
          a.download = "webcli_filesystem.zip";
          a.click();
          URL.revokeObjectURL(url);
          print("âœ… ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãŒå®Œäº†ã—ã¾ã—ãŸ", "success");
          updateStatus("ZIPã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†");
        } catch (error) {
          print(`ã‚¨ãƒ©ãƒ¼: ZIPä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, "error");
        }
      }

      async function importZip() {
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".zip";
        fileInput.style.display = 'none';
        document.body.appendChild(fileInput);

        fileInput.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            print("ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...", "info");
            try {
              const zip = await JSZip.loadAsync(file);
              const newVfs = { type: "dir", children: {} };

              const files = Object.keys(zip.files).filter(path => !zip.files[path].dir);
              
              for (const path of files) {
                const content = await zip.files[path].async("string");
                const parts = path.split('/');
                let currentDir = newVfs;
                
                for (let i = 0; i < parts.length - 1; i++) {
                  const dirName = parts[i];
                  if (!currentDir.children[dirName]) {
                    currentDir.children[dirName] = { type: "dir", children: {} };
                  }
                  currentDir = currentDir.children[dirName];
                }
                
                const fileName = parts[parts.length - 1];
                currentDir.children[fileName] = {
                  type: "file",
                  content: content,
                  ctime: new Date().toISOString(),
                  mtime: new Date().toISOString()
                };
              }
              
              vfs = newVfs;
              cwd = [];
              updatePrompt();
              saveVFS();
              print("âœ… ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’å¾©å…ƒã—ã¾ã—ãŸ", "success");
              updateStatus("ZIPã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†");
              
            } catch (error) {
              print(`ã‚¨ãƒ©ãƒ¼: ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, "error");
            }
          }
          document.body.removeChild(fileInput);
        };
        fileInput.click();
      }

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          const line = input.value.trim();
          input.value = "";
          processCommand(line);
          suggestions.style.display = "none";
          completionIndex = -1;
          selectedSuggestion = -1;
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          if (history.length > 0) {
            historyIndex = Math.max(0, historyIndex - 1);
            input.value = history[historyIndex] || "";
          }
          suggestions.style.display = "none";
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          if (history.length > 0) {
            historyIndex = Math.min(history.length, historyIndex + 1);
            input.value = history[historyIndex] || "";
            if (historyIndex === history.length) {
              input.value = "";
            }
          }
          suggestions.style.display = "none";
        } else if (e.key === "Tab") {
          e.preventDefault();
          if (suggestions.children.length > 0) {
            selectedSuggestion = (selectedSuggestion + 1) % suggestions.children.length;
            const selected = suggestions.children[selectedSuggestion];
            input.value = selected.textContent.trim();
          } else {
            // è‡ªå‹•è£œå®Œãƒ­ã‚¸ãƒƒã‚¯
            const currentText = input.value.trim();
            const parts = currentText.split(/\s+/);
            const cmd = parts[0];
            const partial = parts.length > 1 ? parts.slice(-1)[0] : cmd;
            const fullPath = resolvePath(partial);
            const parentDir = getNode(fullPath.slice(0, -1));
            const baseName = fullPath.slice(-1)[0];
            const completions = Object.keys(parentDir.children).filter(name => name.startsWith(baseName));

            if (completions.length === 1) {
              input.value = currentText.replace(new RegExp(`${baseName}$`), completions[0] + (parentDir.children[completions[0]].type === 'dir' ? '/' : ''));
            } else if (completions.length > 1) {
              print(completions.join("  "));
            }
          }
        } else if (e.ctrlKey && e.key === "l") {
          e.preventDefault();
          processCommand("clear");
        }
      });

      input.addEventListener("input", () => {
        const value = input.value.trim();
        if (value.length > 0) {
          const matchingCommands = Object.keys(commands).filter(cmd => cmd.startsWith(value));
          if (matchingCommands.length > 0) {
            suggestions.innerHTML = "";
            matchingCommands.forEach(cmd => {
              const suggestionEl = document.createElement("div");
              suggestionEl.className = "suggestion";
              suggestionEl.textContent = cmd;
              suggestionEl.addEventListener("click", () => {
                input.value = cmd;
                suggestions.style.display = "none";
                input.focus();
              });
              suggestions.appendChild(suggestionEl);
            });
            suggestions.style.display = "block";
            selectedSuggestion = -1;
          } else {
            suggestions.style.display = "none";
          }
        } else {
          suggestions.style.display = "none";
        }
      });

      // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç›´æ¥å¤‰æ›´
      terminal.addEventListener("dblclick", (e) => {
        const fileDisplay = e.target.closest('.file-name-display');
        if (fileDisplay) {
          const oldName = fileDisplay.dataset.filename;
          const node = getNode(cwd);
          const item = node.children[oldName];
          if (item) {
            enableRename(fileDisplay, oldName);
          }
        }
      });

      // UIãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      helpBtn.addEventListener("click", () => {
        overlay.classList.remove("hidden");
      });
      closeBtn.addEventListener("click", () => {
        overlay.classList.add("hidden");
        input.focus();
      });
      themeBtn.addEventListener("click", () => {
        currentTheme = (currentTheme + 1) % themeKeys.length;
        applyTheme();
      });
      exportZipBtn.addEventListener("click", exportZip);
      importZipBtn.addEventListener("click", importZip);
      clearBtn.addEventListener("click", () => {
        processCommand("clear");
      });

      // ã‚¨ãƒ‡ã‚£ã‚¿ãƒœã‚¿ãƒ³
      btnSave.addEventListener("click", () => {
        if (currentEditFile) {
          const node = getNode(cwd);
          const file = node.children[currentEditFile];
          if (file) {
            file.content = editorText.value;
            setFileDates(file, false);
            saveVFS();
            print(`âœ… ãƒ•ã‚¡ã‚¤ãƒ« '${currentEditFile}' ã‚’ä¿å­˜ã—ã¾ã—ãŸ`, "success");
          }
        }
        closeEditor();
      });

      btnCancel.addEventListener("click", () => {
        closeEditor();
      });

      // åˆæœŸåŒ–
      applyTheme();
      updatePrompt();
      updateFileCount();
      print("=== Enhanced Web CLI ===", "info");
      print("ã‚¿ã‚¤ãƒ— 'help' ã§ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚", "info");
      input.focus();
    });
  </script>
</body>
</html>
