<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Enhanced Web CLI - 高機能ターミナル</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #00ff88;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: background 0.5s ease;
    }

    #header {
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      padding: 10px 15px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #header h1 {
      margin: 0;
      font-size: 1.2em;
      color: #00ff88;
      text-shadow: 0 0 10px #00ff88;
    }

    #controls {
      display: flex;
      gap: 10px;
    }

    #controls button {
      padding: 5px 10px;
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid #00ff88;
      border-radius: 5px;
      color: #00ff88;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9em;
    }

    #controls button:hover {
      background: rgba(0, 255, 136, 0.2);
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }

    #terminal {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.4;
      -webkit-user-select: text;
      user-select: text;
    }

    .line {
      margin: 3px 0;
      display: flex;
      align-items: flex-start;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-5px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .output {
      flex: 1;
      padding: 2px 6px;
      border-radius: 3px;
      word-wrap: break-word;
    }

    .copyBtn {
      margin-left: 8px;
      cursor: pointer;
      opacity: 0.4;
      transition: opacity 0.2s;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 0.8em;
    }

    .copyBtn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
    }

    .help-highlight {
      background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
      color: #fff;
      padding: 4px 8px;
      border-radius: 5px;
      margin: 2px 0;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .prompt-line {
      display: flex;
      align-items: center;
      padding: 12px 15px;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      border-top: 1px solid #444;
      position: relative;
    }

    #promptLabel {
      color: #ff79c6;
      margin-right: 10px;
      white-space: nowrap;
      user-select: none;
      font-weight: bold;
      min-width: 200px;
      text-shadow: 0 0 5px #ff79c6;
    }

    #input {
      flex: 1;
      font-size: 1em;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(0, 255, 136, 0.3);
      border-radius: 5px;
      outline: none;
      color: #00ff88;
      font-family: inherit;
      padding: 8px 12px;
      transition: all 0.3s;
    }

    #input:focus {
      border-color: #00ff88;
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }

    #suggestions {
      position: absolute;
      bottom: 100%;
      left: 215px;
      right: 15px;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid #444;
      border-radius: 5px;
      max-height: 150px;
      overflow-y: auto;
      display: none;
    }

    .suggestion {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #333;
      transition: background 0.2s;
    }

    .suggestion:hover,
    .suggestion.selected {
      background: rgba(0, 255, 136, 0.1);
    }

    .suggestion:last-child {
      border-bottom: none;
    }

    .error {
      color: #ff5555;
    }

    .success {
      color: #50fa7b;
    }

    .info {
      color: #8be9fd;
    }

    .warning {
      color: #f1fa8c;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
      padding: 20px;
      z-index: 1000;
    }

    .hidden {
      display: none;
    }

    .overlay-content {
      background: linear-gradient(135deg, #2d2d2d, #1a1a2e);
      color: #f8f8f2;
      padding: 25px;
      border-radius: 10px;
      border: 1px solid #444;
      max-width: 90%;
      width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .overlay-content h2 {
      color: #00ff88;
      text-align: center;
      margin-top: 0;
      text-shadow: 0 0 10px #00ff88;
    }

    .overlay-content ul {
      list-style: none;
      padding: 0;
    }

    .overlay-content li {
      margin-bottom: 8px;
      padding: 5px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 5px;
      border-left: 3px solid #00ff88;
    }

    .overlay-content code {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 5px;
      border-radius: 3px;
      color: #ff79c6;
    }

    .overlay-content button {
      margin: 15px 5px 5px;
      padding: 10px 16px;
      background: linear-gradient(45deg, #444, #666);
      border: none;
      border-radius: 5px;
      color: #eee;
      cursor: pointer;
      transition: all 0.3s;
    }

    .overlay-content button:hover {
      background: linear-gradient(45deg, #555, #777);
      transform: translateY(-2px);
    }

    #editorOverlay textarea {
      width: 100%;
      height: 350px;
      background: rgba(0, 0, 0, 0.5);
      color: #f8f8f2;
      border: 1px solid #444;
      border-radius: 5px;
      outline: none;
      font-family: inherit;
      font-size: 1em;
      padding: 12px;
      resize: vertical;
      transition: border-color 0.3s;
    }

    #editorOverlay textarea:focus {
      border-color: #00ff88;
    }

    .btnGroup {
      margin-top: 12px;
      text-align: right;
    }

    .btnGroup button {
      margin-left: 10px;
    }

    .status-bar {
      background: rgba(0, 0, 0, 0.3);
      padding: 5px 15px;
      font-size: 0.9em;
      color: #888;
      border-top: 1px solid #333;
    }

    .file-icon {
      display: inline-block;
      width: 16px;
      text-align: center;
      margin-right: 5px;
    }

    .clickable-file {
      cursor: pointer;
      color: #8be9fd;
      text-decoration: underline;
      text-underline-offset: 3px;
      text-decoration-thickness: 1px;
      transition: color 0.2s;
    }

    .clickable-file:hover {
      color: #f1fa8c;
    }

    .ls-file-info {
      display: inline-block;
      width: 100px;
      color: #888;
    }

    .ls-date-info {
      display: inline-block;
      width: 200px;
      color: #888;
    }

    .ls-permissions {
      display: inline-block;
      width: 100px;
      color: #50fa7b;
    }
    
    .file-entry-container {
      display: flex;
      align-items: center;
      flex: 1;
    }

    .file-name-input {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ff88;
      color: #fff;
      font-family: inherit;
      font-size: 1em;
      padding: 2px 6px;
      border-radius: 3px;
      outline: none;
      flex: 1;
    }

    /* スクロールバーのスタイル */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 136, 0.3);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 255, 136, 0.5);
    }
  </style>
</head>

<body>
  <div id="header">
    <h1>🚀 Enhanced Web CLI</h1>
    <div id="controls">
      <button id="helpBtn" title="ヘルプ">❓ Help</button>
      <button id="themeBtn" title="テーマ切替">🎨 Theme</button>
      <button id="exportZipBtn" title="ZIPにまとめて保存">📥 ZIP Export</button>
      <button id="importZipBtn" title="ZIPから読み込み">📤 ZIP Import</button>
      <button id="clearBtn" title="画面クリア">🗑️ Clear</button>
    </div>
  </div>
  <div id="terminal" aria-live="polite" aria-atomic="false"></div>
  <div class="prompt-line" role="region" aria-label="コマンド入力">
    <span id="promptLabel">user@webcli:/ $</span>
    <input id="input" autocomplete="off" placeholder="コマンドを入力... (Tab で補完)" />
    <div id="suggestions"></div>
  </div>
  <div class="status-bar">
    <span id="statusText">Ready</span> | Files: <span id="fileCount">0</span> | Last: <span id="lastCommand">-</span>
  </div>
  <div id="cmdOverlay" class="overlay hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="overlay-content">
      <h2 id="helpTitle">📚 コマンド一覧</h2>
      <ul id="helpList">
        <li><code>help</code> : コマンド一覧と説明を表示</li>
        <li><code>pwd</code> : カレントディレクトリ表示</li>
        <li><code>ls [-l] [path]</code> : ディレクトリ一覧。-lで詳細表示</li>
        <li><code>cd &lt;dir&gt;</code> : ディレクトリ移動</li>
        <li><code>mkdir &lt;dir&gt;</code> : ディレクトリ作成</li>
        <li><code>touch &lt;file&gt;</code> : 空ファイル作成</li>
        <li><code>cat &lt;file&gt;</code> : ファイル内容表示</li>
        <li><code>write &lt;file&gt; text</code> : ファイルに上書き</li>
        <li><code>append &lt;file&gt; text</code> : ファイルに追記</li>
        <li><code>rm &lt;file/dir&gt;</code> : ファイル/ディレクトリ削除</li>
        <li><code>mv &lt;from&gt; &lt;to&gt;</code> : ファイル/ディレクトリ移動・リネーム</li>
        <li><code>cp &lt;from&gt; &lt;to&gt;</code> : ファイル/ディレクトリコピー</li>
        <li><code>find &lt;name&gt;</code> : ファイル/ディレクトリ検索</li>
        <li><code>tree [path]</code> : ファイルツリー表示</li>
        <li><code>clear</code> : 画面クリア</li>
        <li><code>edit &lt;file&gt;</code> : テキストエディタ起動</li>
        <li><code>history</code> : コマンド履歴表示</li>
        <li><code>export</code> : ファイルシステムをJSONでエクスポート</li>
        <li><code>import</code> : JSONからファイルシステムをインポート</li>
        <li><code>reset</code> : ファイルシステムをリセット</li>
      </ul>
      <div style="text-align: center;">
        <button id="closeOverlay">閉じる</button>
      </div>
    </div>
  </div>
  <div id="editorOverlay" class="overlay hidden" role="dialog" aria-modal="true" aria-labelledby="editTitle">
    <div class="overlay-content">
      <h2 id="editTitle">📝 ファイル編集</h2>
      <textarea id="editorText" aria-label="ファイル編集エリア" placeholder="ファイルの内容を入力..."></textarea>
      <div class="btnGroup">
        <button id="btnSave">💾 保存</button>
        <button id="btnCancel">❌ キャンセル</button>
      </div>
    </div>
  </div>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const terminal = document.getElementById("terminal");
      const input = document.getElementById("input");
      const promptLabel = document.getElementById("promptLabel");
      const suggestions = document.getElementById("suggestions");
      const helpBtn = document.getElementById("helpBtn");
      const themeBtn = document.getElementById("themeBtn");
      const exportZipBtn = document.getElementById("exportZipBtn");
      const importZipBtn = document.getElementById("importZipBtn");
      const clearBtn = document.getElementById("clearBtn");
      const overlay = document.getElementById("cmdOverlay");
      const closeBtn = document.getElementById("closeOverlay");
      const editorOverlay = document.getElementById("editorOverlay");
      const editorText = document.getElementById("editorText");
      const btnSave = document.getElementById("btnSave");
      const btnCancel = document.getElementById("btnCancel");
      const statusText = document.getElementById("statusText");
      const fileCount = document.getElementById("fileCount");
      const lastCommand = document.getElementById("lastCommand");

      // テーマ設定
      const themes = {
        default: {
          bg: 'linear-gradient(135deg, #1a1a2e, #16213e)',
          text: '#00ff88',
          accent: '#ff79c6',
          secondary: '#8be9fd'
        },
        matrix: {
          bg: 'linear-gradient(135deg, #000000, #0d1b0d)',
          text: '#00ff00',
          accent: '#ffffff',
          secondary: '#ffffff'
        },
        cyberpunk: {
          bg: 'linear-gradient(135deg, #0f0f2e, #2e0f2e)',
          text: '#ff00ff',
          accent: '#00ffff',
          secondary: '#8be9fd'
        }
      };

      let currentTheme = 0;
      const themeKeys = Object.keys(themes);

      function applyTheme() {
        const theme = themes[themeKeys[currentTheme]];
        document.body.style.background = theme.bg;
        document.body.style.color = theme.text;
        document.documentElement.style.setProperty('--accent-color', theme.accent);
        document.documentElement.style.setProperty('--secondary-color', theme.secondary);
      }

      // VFS構造体＆初期化
      let vfs = JSON.parse(localStorage.getItem("VFS")) || {
        type: "dir",
        children: {
          "welcome.txt": {
            type: "file",
            content: "Enhanced Web CLI へようこそ！\n\nこのターミナルでは以下のことができます:\n- ファイル・ディレクトリ操作\n- テキストエディタ\n- 検索・コピー・移動\n- データのエクスポート・インポート\n\n'help' コマンドで詳細を確認してください。",
            ctime: new Date().toISOString(),
            mtime: new Date().toISOString()
          },
          "docs": {
            type: "dir",
            children: {
              "readme.md": {
                type: "file",
                content: "# Enhanced Web CLI\n\n高機能なWebベースのターミナルエミュレータです。\n\n## 特徴\n- 直感的なUI\n- 豊富なコマンド\n- ファイル管理\n- データ永続化",
                ctime: new Date().toISOString(),
                mtime: new Date().toISOString()
              }
            }
          }
        }
      };
      let cwd = []; // カレントディレクトリ パス配列
      const history = JSON.parse(localStorage.getItem("CLI_HISTORY")) || [];
      let historyIndex = history.length;
      let completionList = [];
      let completionIndex = -1;
      let selectedSuggestion = -1;

      function saveVFS() {
        localStorage.setItem("VFS", JSON.stringify(vfs));
        updateFileCount();
      }

      function saveHistory() {
        localStorage.setItem("CLI_HISTORY", JSON.stringify(history.slice(-50))); // 最新50件のみ保存
      }

      function getNode(path) {
        let node = vfs;
        for (let p of path) {
          if (node.type === "dir" && node.children[p]) {
            node = node.children[p];
          } else {
            return null;
          }
        }
        return node;
      }

      function ensureDir(node) {
        return node && node.type === "dir";
      }

      function getFileIcon(file) {
        if (file.type === "dir") return "📁";
        const name = file.name || "";
        if (name.endsWith(".txt")) return "📄";
        if (name.endsWith(".md")) return "📝";
        if (name.endsWith(".js")) return "📜";
        if (name.endsWith(".html")) return "🌐";
        if (name.endsWith(".css")) return "🎨";
        if (name.endsWith(".json")) return "🔧";
        return "📄";
      }

      function fmtDate(d) {
        if (!(d instanceof Date)) d = new Date(d);
        return d.toLocaleString('ja-JP');
      }

      function fmtSize(n) {
        if (n < 1024) return n + "B";
        if (n < 1024 * 1024) return (n / 1024).toFixed(1) + "KB";
        if (n < 1024 * 1024 * 1024) return (n / 1024 / 1024).toFixed(1) + "MB";
        return (n / 1024 / 1024 / 1024).toFixed(1) + "GB";
      }

      function fileSize(file) {
        if (typeof file.content === "string") {
          return new TextEncoder().encode(file.content).length;
        }
        return 0;
      }

      function updatePrompt() {
        const pathStr = "/" + (cwd.length === 0 ? "" : cwd.join("/"));
        promptLabel.textContent = `user@webcli:${pathStr} $`;
      }

      function updateFileCount() {
        let count = 0;
        function countFiles(node) {
          if (node.type === "file") count++;
          if (node.type === "dir") {
            Object.values(node.children).forEach(countFiles);
          }
        }
        countFiles(vfs);
        fileCount.textContent = count;
      }

      function updateStatus(message) {
        statusText.textContent = message;
        setTimeout(() => statusText.textContent = "Ready", 3000);
      }

      // 出力関数
      function print(text, cls = "", highlight = false) {
        const line = document.createElement("div");
        line.className = "line";

        const span = document.createElement("span");
        span.className = "output";
        if (cls) span.classList.add(cls);
        if (highlight) span.classList.add("help-highlight");

        span.innerHTML = text.replace(/\n/g, '<br>').replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');

        const copyBtn = document.createElement("span");
        copyBtn.innerHTML = "📋";
        copyBtn.className = "copyBtn";
        copyBtn.title = "コピー";
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(text);
          copyBtn.innerHTML = "✅";
          setTimeout(() => copyBtn.innerHTML = "📋", 1000);
        };

        line.appendChild(span);
        if (text.trim()) line.appendChild(copyBtn);

        terminal.appendChild(line);
        terminal.scrollTop = terminal.scrollHeight;
      }
      
      // ファイル名表示とインプレース編集
      function printFileEntry(icon, name, isFile) {
        const line = document.createElement("div");
        line.className = "line";

        const container = document.createElement("span");
        container.className = "output file-entry-container";

        const iconSpan = document.createElement("span");
        iconSpan.className = "file-icon";
        iconSpan.textContent = icon;

        const nameSpan = document.createElement("span");
        nameSpan.className = "file-name-display";
        nameSpan.textContent = name + (isFile ? "" : "/");

        const copyBtn = document.createElement("span");
        copyBtn.innerHTML = "📋";
        copyBtn.className = "copyBtn";
        copyBtn.title = "パスをコピー";
        copyBtn.onclick = () => {
          const fullPath = "/" + [...cwd, name].join("/");
          navigator.clipboard.writeText(fullPath);
          copyBtn.innerHTML = "✅";
          setTimeout(() => copyBtn.innerHTML = "📋", 1000);
        };

        container.appendChild(iconSpan);
        container.appendChild(nameSpan);

        if (isFile) {
          nameSpan.classList.add("clickable-file");
          nameSpan.title = "ダブルクリックで編集";
          nameSpan.dataset.filename = name;
        } else {
          nameSpan.title = "ダブルクリックで名前変更";
          nameSpan.classList.add("clickable-dir");
          nameSpan.dataset.filename = name;
        }

        line.appendChild(container);
        line.appendChild(copyBtn);
        terminal.appendChild(line);
      }
      
      function enableRename(nameSpan, oldName) {
        const line = nameSpan.closest('.line');
        const iconSpan = line.querySelector('.file-icon');
        const inputField = document.createElement('input');
        inputField.className = 'file-name-input';
        inputField.type = 'text';
        inputField.value = oldName;
        inputField.style.width = `${oldName.length + 2}ch`;

        nameSpan.style.display = 'none';
        iconSpan.after(inputField);
        inputField.focus();
        inputField.select();

        const finishRename = (newName) => {
          if (!newName || newName.trim() === oldName || newName.trim() === '') {
            print("変更がキャンセルされました。", "info");
          } else {
            const node = getNode(cwd);
            if (node.children[newName.trim()]) {
              print(`エラー: '${newName.trim()}' は既に存在します`, "error");
            } else {
              node.children[newName.trim()] = node.children[oldName];
              delete node.children[oldName];
              saveVFS();
              print(`✅ '${oldName}' を '${newName.trim()}' に変更しました`, "success");
              updateStatus("ファイル名変更完了");
            }
          }
          // 元の表示に戻す
          inputField.remove();
          nameSpan.style.display = 'block';
        };

        inputField.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            finishRename(inputField.value);
          } else if (e.key === 'Escape') {
            e.preventDefault();
            finishRename('');
          }
        });

        inputField.addEventListener('blur', () => {
          finishRename(inputField.value);
        });
      }

      // パス解決
      function resolvePath(pathStr) {
        if (!pathStr) return [...cwd];
        let parts = pathStr.split("/").filter(p => p !== "");
        let res = pathStr.startsWith("/") ? [] : [...cwd];

        for (let p of parts) {
          if (p === ".") continue;
          else if (p === "..") res.pop();
          else res.push(p);
        }
        return res;
      }

      // ツリー表示
      function showTree(node, prefix = "", name = "", path = []) {
        let out = "";
        if (name) {
          const icon = getFileIcon(node);
          out += prefix + "├── " + icon + " " + name + (node.type === "dir" ? "/" : "") + "\n";
        }

        if (node.type === "dir") {
          const entries = Object.entries(node.children);
          entries.forEach(([key, child], index) => {
            const isLast = index === entries.length - 1;
            const newPrefix = prefix + (name ? (isLast ? "    " : "│   ") : "");
            out += showTree(child, newPrefix, key, [...path, key]);
          });
        }
        return out;
      }

      // ls -l 詳細表示用関数
      function listDetailedDir(node) {
        const entries = Object.entries(node.children).sort(([a, nodeA], [b, nodeB]) => {
          if (nodeA.type !== nodeB.type) {
            return nodeA.type === "dir" ? -1 : 1;
          }
          return a.localeCompare(b);
        });

        entries.forEach(([key, item]) => {
          const line = document.createElement("div");
          line.className = "line";

          const typeChar = item.type === "dir" ? "d" : "-";
          const perms = "rwxrwxrwx";
          const size = item.type === "file" ? fmtSize(fileSize(item)) : "-";
          const mtime = item.mtime ? fmtDate(item.mtime) : "-";
          const icon = getFileIcon(item);

          const permsSpan = document.createElement("span");
          permsSpan.className = "output ls-permissions";
          permsSpan.textContent = typeChar + perms;

          const sizeSpan = document.createElement("span");
          sizeSpan.className = "output ls-file-info";
          sizeSpan.textContent = size.toString().padStart(8);

          const dateSpan = document.createElement("span");
          dateSpan.className = "output ls-date-info";
          dateSpan.textContent = mtime;
          
          const nameSpan = document.createElement("span");
          nameSpan.className = "file-entry-container";
          nameSpan.innerHTML = `<span class="file-icon">${icon}</span><span class="file-name-display">${key}${item.type === "dir" ? "/" : ""}</span>`;
          nameSpan.dataset.filename = key;
          
          if(item.type === "file"){
            nameSpan.title = "ダブルクリックで編集";
            nameSpan.classList.add("clickable-file");
          } else {
            nameSpan.title = "ダブルクリックで名前変更";
            nameSpan.classList.add("clickable-dir");
          }
          
          line.appendChild(permsSpan);
          line.appendChild(sizeSpan);
          line.appendChild(dateSpan);
          line.appendChild(nameSpan);

          terminal.appendChild(line);
        });
      }

      // ファイル検索
      function findFiles(searchTerm, node = vfs, path = []) {
        let results = [];
        if (node.type === "dir") {
          for (let [name, child] of Object.entries(node.children)) {
            const fullPath = "/" + [...path, name].join("/");
            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
              results.push({
                path: fullPath,
                type: child.type,
                node: child
              });
            }
            if (child.type === "dir") {
              results.push(...findFiles(searchTerm, child, [...path, name]));
            }
          }
        }
        return results;
      }

      // ディレクトリコピー（再帰）
      function copyDir(sourceNode) {
        if (sourceNode.type === "file") {
          return {
            type: "file",
            content: sourceNode.content,
            ctime: new Date().toISOString(),
            mtime: sourceNode.mtime
          };
        } else {
          const newDir = {
            type: "dir",
            children: {}
          };
          for (let [name, child] of Object.entries(sourceNode.children)) {
            newDir.children[name] = copyDir(child);
          }
          return newDir;
        }
      }

      // コマンド一覧
      const commands = {
        help: "コマンド一覧と説明を表示",
        pwd: "現在のディレクトリ表示",
        ls: "ディレクトリ一覧。-lで詳細表示",
        cd: "ディレクトリ移動",
        mkdir: "ディレクトリ作成",
        touch: "空ファイル作成",
        cat: "ファイル内容表示",
        write: "ファイルに上書き",
        append: "ファイルに追記",
        rm: "ファイル/ディレクトリ削除",
        mv: "ファイル/ディレクトリ移動・リネーム",
        cp: "ファイル/ディレクトリコピー",
        find: "ファイル/ディレクトリ検索",
        tree: "ファイルツリー表示",
        clear: "画面クリア",
        edit: "テキストエディタ起動",
        history: "コマンド履歴表示",
        export: "ファイルシステムをJSONでエクスポート",
        import: "JSONからファイルシステムをインポート",
        reset: "ファイルシステムをリセット"
      };

      // HELP表示
      function showHelp() {
        print("🚀 Enhanced Web CLI - コマンド一覧", "info");
        print("=" .repeat(50), "info");

        Object.entries(commands).forEach(([cmd, desc]) => {
          print(`${cmd.padEnd(12)} : ${desc}`, "", true);
        });

        print("\n💡 ヒント:", "info");
        print("- Tab キーで補完", "success");
        print("- ↑↓ キーで履歴", "success");
        print("- ファイル名をダブルクリックで編集・名前変更", "success");
      }

      // ファイル作成/編集時の日付付与
      function setFileDates(file, isNew) {
        const now = new Date().toISOString();
        if (isNew) {
          file.ctime = now;
          file.mtime = now;
        } else {
          file.mtime = now;
        }
      }

      // コマンド処理
      function processCommand(line) {
        if (!line.trim()) return;

        print(`> ${line}`, "info");

        history.push(line);
        historyIndex = history.length;
        saveHistory();
        lastCommand.textContent = line.split(' ')[0];

        const args = line.trim().split(/\s+/);
        const cmd = args[0];
        const rest = args.slice(1);

        try {
          switch (cmd) {
            case "help":
              showHelp();
              updateStatus("ヘルプを表示しました");
              break;

            case "pwd":
              print("/" + cwd.join("/"));
              updateStatus("カレントディレクトリを表示");
              break;

            case "ls": {
              const node = getNode(cwd);
              if (!ensureDir(node)) {
                print("エラー: 不正なディレクトリ", "error");
                break;
              }

              const isDetailed = rest.includes("-l");
              const entries = Object.entries(node.children).sort(([a, nodeA], [b, nodeB]) => {
                if (nodeA.type !== nodeB.type) {
                  return nodeA.type === "dir" ? -1 : 1;
                }
                return a.localeCompare(b);
              });

              if (isDetailed) {
                listDetailedDir(node);
              } else {
                entries.forEach(([name, child]) => {
                  const icon = getFileIcon(child);
                  printFileEntry(icon, name, child.type === "file");
                });
                if (entries.length === 0) {
                  print("（空のディレクトリ）", "warning");
                }
              }
              updateStatus(`${entries.length} 個のアイテムを表示`);
              break;
            }

            case "cd": {
              if (rest.length === 0) {
                cwd = [];
                updatePrompt();
                print("ホームディレクトリに移動しました");
                break;
              }

              const path = resolvePath(rest[0]);
              const node = getNode(path);
              if (ensureDir(node)) {
                cwd = path;
                updatePrompt();
                print(`移動しました: /${cwd.join("/")}`);
                updateStatus(`${rest[0]} に移動`);
              } else {
                print(`エラー: ディレクトリ '${rest[0]}' が存在しません`, "error");
              }
              break;
            }

            case "mkdir": {
              if (rest.length === 0) {
                print("エラー: ディレクトリ名が必要です", "error");
                break;
              }

              const node = getNode(cwd);
              if (!ensureDir(node)) {
                print("エラー: カレントディレクトリが無効です", "error");
                break;
              }

              const dirName = rest[0];
              if (node.children[dirName]) {
                print(`エラー: '${dirName}' は既に存在します`, "error");
                break;
              }

              node.children[dirName] = {
                type: "dir",
                children: {},
                ctime: new Date().toISOString(),
                mtime: new Date().toISOString()
              };
              saveVFS();
              print(`✅ ディレクトリ '${dirName}' を作成しました`, "success");
              updateStatus("ディレクトリ作成完了");
              break;
            }

            case "touch": {
              if (rest.length === 0) {
                print("エラー: ファイル名が必要です", "error");
                break;
              }

              const node = getNode(cwd);
              const fileName = rest[0];

              if (node.children[fileName]) {
                if (node.children[fileName].type === "file") {
                  setFileDates(node.children[fileName], false);
                  print(`📝 ファイル '${fileName}' のタイムスタンプを更新しました`, "success");
                } else {
                  print(`エラー: '${fileName}' はディレクトリです`, "error");
                }
                break;
              }

              const newFile = {
                type: "file",
                content: ""
              };
              setFileDates(newFile, true);
              node.children[fileName] = newFile;
              saveVFS();
              print(`✅ ファイル '${fileName}' を作成しました`, "success");
              updateStatus("ファイル作成完了");
              break;
            }

            case "cat": {
              if (rest.length === 0) {
                print("エラー: ファイル名が必要です", "error");
                break;
              }

              const node = getNode(cwd);
              const file = node.children[rest[0]];

              if (file && file.type === "file") {
                if (file.content.trim()) {
                  print("📄 " + file.content);
                } else {
                  print("（空のファイル）", "warning");
                }
                updateStatus("ファイル内容を表示");
              } else {
                print(`エラー: ファイル '${rest[0]}' が存在しません`, "error");
              }
              break;
            }

            case "write": {
              if (rest.length < 2) {
                print("エラー: ファイル名と内容が必要です", "error");
                print("使用法: write <ファイル名> <内容>", "info");
                break;
              }

              const node = getNode(cwd);
              const fileName = rest[0];
              const content = rest.slice(1).join(" ");

              let targetFile = node.children[fileName];
              if (!targetFile) {
                targetFile = {
                  type: "file",
                  content: ""
                };
                setFileDates(targetFile, true);
                node.children[fileName] = targetFile;
              }

              if (targetFile.type !== "file") {
                print(`エラー: '${fileName}' はディレクトリです`, "error");
                break;
              }

              targetFile.content = content;
              setFileDates(targetFile, false);
              saveVFS();
              print(`✅ ファイル '${fileName}' に書き込みました`, "success");
              updateStatus("ファイル書き込み完了");
              break;
            }

            case "append": {
              if (rest.length < 2) {
                print("エラー: ファイル名と内容が必要です", "error");
                print("使用法: append <ファイル名> <内容>", "info");
                break;
              }

              const node = getNode(cwd);
              const fileName = rest[0];
              const content = rest.slice(1).join(" ");

              let targetFile = node.children[fileName];
              if (!targetFile) {
                targetFile = {
                  type: "file",
                  content: ""
                };
                setFileDates(targetFile, true);
                node.children[fileName] = targetFile;
              }

              if (targetFile.type !== "file") {
                print(`エラー: '${fileName}' はディレクトリです`, "error");
                break;
              }

              targetFile.content += (targetFile.content ? "\n" : "") + content;
              setFileDates(targetFile, false);
              saveVFS();
              print(`✅ ファイル '${fileName}' に追記しました`, "success");
              updateStatus("ファイル追記完了");
              break;
            }

            case "rm": {
              if (rest.length === 0) {
                print("エラー: 削除対象を指定してください", "error");
                break;
              }

              const node = getNode(cwd);
              const target = rest[0];

              if (!node.children[target]) {
                print(`エラー: '${target}' が見つかりません`, "error");
                break;
              }

              if (node.children[target].type === "dir") {
                const dirNode = node.children[target];
                const itemCount = Object.keys(dirNode.children).length;
                if (itemCount > 0) {
                  print(`⚠️ ディレクトリ '${target}' には ${itemCount} 個のアイテムがあります`, "warning");
                  print("本当に削除しますか？ [Y/N]");

                  const confirmed = confirm(`ディレクトリ '${target}' とその中身を削除しますか？`);
                  if (!confirmed) {
                    print("削除をキャンセルしました");
                    break;
                  }
                }
              }

              delete node.children[target];
              saveVFS();
              print(`✅ '${target}' を削除しました`, "success");
              updateStatus("削除完了");
              break;
            }

            case "mv": {
              if (rest.length < 2) {
                print("エラー: 移動元と移動先が必要です", "error");
                print("使用法: mv <移動元> <移動先>", "info");
                break;
              }

              const node = getNode(cwd);
              const from = rest[0];
              const to = rest[1];

              if (!node.children[from]) {
                print(`エラー: '${from}' が見つかりません`, "error");
                break;
              }

              if (node.children[to]) {
                print(`エラー: '${to}' は既に存在します`, "error");
                break;
              }

              node.children[to] = node.children[from];
              delete node.children[from];
              saveVFS();
              print(`✅ '${from}' を '${to}' に移動しました`, "success");
              updateStatus("移動完了");
              break;
            }

            case "cp": {
              if (rest.length < 2) {
                print("エラー: コピー元とコピー先が必要です", "error");
                print("使用法: cp <コピー元> <コピー先>", "info");
                break;
              }

              const node = getNode(cwd);
              const from = rest[0];
              const to = rest[1];

              if (!node.children[from]) {
                print(`エラー: '${from}' が見つかりません`, "error");
                break;
              }

              if (node.children[to]) {
                print(`エラー: '${to}' は既に存在します`, "error");
                break;
              }

              node.children[to] = copyDir(node.children[from]);
              saveVFS();
              print(`✅ '${from}' を '${to}' にコピーしました`, "success");
              updateStatus("コピー完了");
              break;
            }

            case "find": {
              if (rest.length === 0) {
                print("エラー: 検索語が必要です", "error");
                print("使用法: find <検索語>", "info");
                break;
              }

              const searchTerm = rest[0];
              const results = findFiles(searchTerm);

              if (results.length === 0) {
                print(`'${searchTerm}' にマッチするアイテムは見つかりませんでした`, "warning");
              } else {
                print(`🔍 '${searchTerm}' の検索結果 (${results.length}件):`, "info");
                results.forEach(result => {
                  const icon = getFileIcon(result.node);
                  print(`${icon} ${result.path} (${result.type})`);
                });
              }
              updateStatus(`検索完了: ${results.length}件`);
              break;
            }

            case "tree": {
              const path = rest[0] ? resolvePath(rest[0]) : cwd;
              const node = getNode(path);

              if (!node) {
                print("エラー: パスが見つかりません", "error");
                break;
              }

              const pathStr = "/" + path.join("/");
              print(`📁 ${pathStr}`, "info");
              const tree = showTree(node);
              if (tree) {
                print(tree);
              } else {
                print("└── （空）");
              }
              updateStatus("ツリー表示完了");
              break;
            }

            case "clear":
              terminal.innerHTML = "";
              updateStatus("画面をクリア");
              break;

            case "edit": {
              if (rest.length === 0) {
                print("エラー: ファイル名を指定してください", "error");
                break;
              }
              const fileName = rest[0];
              const node = getNode(cwd);
              let file = node.children[fileName];

              if (!file) {
                const create = confirm(`ファイル '${fileName}' は存在しません。新しく作成しますか？`);
                if (!create) {
                  print("編集をキャンセルしました");
                  break;
                }
                file = {
                  type: "file",
                  content: ""
                };
                setFileDates(file, true);
                node.children[fileName] = file;
              }

              if (file.type !== "file") {
                print(`エラー: '${fileName}' はディレクトリです`, "error");
                break;
              }

              openEditor(fileName, file.content);
              break;
            }

            case "history": {
              if (history.length === 0) {
                print("履歴がありません", "warning");
              } else {
                print("📚 コマンド履歴:", "info");
                history.slice(-20).forEach((cmd, i) => {
                  const num = (history.length - 20 + i + 1).toString().padStart(3);
                  print(`${num}: ${cmd}`);
                });
              }
              updateStatus(`履歴表示: ${history.length}件`);
              break;
            }

            case "export": {
              const data = JSON.stringify(vfs, null, 2);
              const blob = new Blob([data], {
                type: "application/json"
              });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "filesystem_export.json";
              a.click();
              URL.revokeObjectURL(url);
              print("✅ ファイルシステムをエクスポートしました", "success");
              updateStatus("エクスポート完了");
              break;
            }

            case "import": {
              const fileInput = document.createElement("input");
              fileInput.type = "file";
              fileInput.accept = ".json";
              fileInput.style.display = 'none';
              document.body.appendChild(fileInput);

              fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                  const reader = new FileReader();
                  reader.onload = (e) => {
                    try {
                      const data = JSON.parse(e.target.result);
                      if (data.type === "dir" && data.children) {
                        vfs = data;
                        cwd = [];
                        updatePrompt();
                        saveVFS();
                        print("✅ ファイルシステムをインポートしました", "success");
                        updateStatus("インポート完了");
                      } else {
                        print("エラー: 無効なファイル形式です", "error");
                      }
                    } catch (err) {
                      print("エラー: JSONの解析に失敗しました", "error");
                    }
                  };
                  reader.readAsText(file);
                }
                document.body.removeChild(fileInput);
              };
              fileInput.click();
              break;
            }

            case "reset": {
              const confirmed = confirm("ファイルシステムを完全にリセットしますか？この操作は元に戻せません。");
              if (confirmed) {
                vfs = {
                  type: "dir",
                  children: {}
                };
                cwd = [];
                updatePrompt();
                saveVFS();
                localStorage.removeItem("CLI_HISTORY");
                terminal.innerHTML = "";
                print("🔄 ファイルシステムをリセットしました", "success");
                print("=== Enhanced Web CLI - 新しいセッション ===", "info");
                updateStatus("リセット完了");
              }
              break;
            }

            default:
              print(`未知のコマンド: ${cmd}`, "error");
              print("'help' でコマンド一覧を確認してください", "info");
          }
        } catch (error) {
          print(`エラーが発生しました: ${error.message}`, "error");
          console.error("Command execution error:", error);
        }
      }

      // エディタオーバーレイ管理
      let currentEditFile = null;

      function openEditor(filename, content) {
        currentEditFile = filename;
        editorText.value = content;
        editorOverlay.classList.remove("hidden");
        editorText.focus();
      }

      function closeEditor() {
        editorOverlay.classList.add("hidden");
        currentEditFile = null;
        input.focus();
      }

      // ZIP処理
      async function exportZip() {
        print("アーカイブを作成中...", "info");
        const zip = new JSZip();

        function addFilesToZip(node, path) {
          if (node.type === "file") {
            zip.file(path, node.content);
          } else if (node.type === "dir") {
            for (const [name, child] of Object.entries(node.children)) {
              addFilesToZip(child, path ? `${path}/${name}` : name);
            }
          }
        }
        addFilesToZip(vfs, "");

        try {
          const content = await zip.generateAsync({ type: "blob" });
          const url = URL.createObjectURL(content);
          const a = document.createElement("a");
          a.href = url;
          a.download = "webcli_filesystem.zip";
          a.click();
          URL.revokeObjectURL(url);
          print("✅ ZIPファイルのエクスポートが完了しました", "success");
          updateStatus("ZIPエクスポート完了");
        } catch (error) {
          print(`エラー: ZIP作成に失敗しました: ${error.message}`, "error");
        }
      }

      async function importZip() {
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".zip";
        fileInput.style.display = 'none';
        document.body.appendChild(fileInput);

        fileInput.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            print("ZIPファイルを読み込み中...", "info");
            try {
              const zip = await JSZip.loadAsync(file);
              const newVfs = { type: "dir", children: {} };

              const files = Object.keys(zip.files).filter(path => !zip.files[path].dir);
              
              for (const path of files) {
                const content = await zip.files[path].async("string");
                const parts = path.split('/');
                let currentDir = newVfs;
                
                for (let i = 0; i < parts.length - 1; i++) {
                  const dirName = parts[i];
                  if (!currentDir.children[dirName]) {
                    currentDir.children[dirName] = { type: "dir", children: {} };
                  }
                  currentDir = currentDir.children[dirName];
                }
                
                const fileName = parts[parts.length - 1];
                currentDir.children[fileName] = {
                  type: "file",
                  content: content,
                  ctime: new Date().toISOString(),
                  mtime: new Date().toISOString()
                };
              }
              
              vfs = newVfs;
              cwd = [];
              updatePrompt();
              saveVFS();
              print("✅ ZIPファイルからファイルシステムを復元しました", "success");
              updateStatus("ZIPインポート完了");
              
            } catch (error) {
              print(`エラー: ZIPファイルの読み込みに失敗しました: ${error.message}`, "error");
            }
          }
          document.body.removeChild(fileInput);
        };
        fileInput.click();
      }

      // イベントリスナー
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          const line = input.value.trim();
          input.value = "";
          processCommand(line);
          suggestions.style.display = "none";
          completionIndex = -1;
          selectedSuggestion = -1;
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          if (history.length > 0) {
            historyIndex = Math.max(0, historyIndex - 1);
            input.value = history[historyIndex] || "";
          }
          suggestions.style.display = "none";
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          if (history.length > 0) {
            historyIndex = Math.min(history.length, historyIndex + 1);
            input.value = history[historyIndex] || "";
            if (historyIndex === history.length) {
              input.value = "";
            }
          }
          suggestions.style.display = "none";
        } else if (e.key === "Tab") {
          e.preventDefault();
          if (suggestions.children.length > 0) {
            selectedSuggestion = (selectedSuggestion + 1) % suggestions.children.length;
            const selected = suggestions.children[selectedSuggestion];
            input.value = selected.textContent.trim();
          } else {
            // 自動補完ロジック
            const currentText = input.value.trim();
            const parts = currentText.split(/\s+/);
            const cmd = parts[0];
            const partial = parts.length > 1 ? parts.slice(-1)[0] : cmd;
            const fullPath = resolvePath(partial);
            const parentDir = getNode(fullPath.slice(0, -1));
            const baseName = fullPath.slice(-1)[0];
            const completions = Object.keys(parentDir.children).filter(name => name.startsWith(baseName));

            if (completions.length === 1) {
              input.value = currentText.replace(new RegExp(`${baseName}$`), completions[0] + (parentDir.children[completions[0]].type === 'dir' ? '/' : ''));
            } else if (completions.length > 1) {
              print(completions.join("  "));
            }
          }
        } else if (e.ctrlKey && e.key === "l") {
          e.preventDefault();
          processCommand("clear");
        }
      });

      input.addEventListener("input", () => {
        const value = input.value.trim();
        if (value.length > 0) {
          const matchingCommands = Object.keys(commands).filter(cmd => cmd.startsWith(value));
          if (matchingCommands.length > 0) {
            suggestions.innerHTML = "";
            matchingCommands.forEach(cmd => {
              const suggestionEl = document.createElement("div");
              suggestionEl.className = "suggestion";
              suggestionEl.textContent = cmd;
              suggestionEl.addEventListener("click", () => {
                input.value = cmd;
                suggestions.style.display = "none";
                input.focus();
              });
              suggestions.appendChild(suggestionEl);
            });
            suggestions.style.display = "block";
            selectedSuggestion = -1;
          } else {
            suggestions.style.display = "none";
          }
        } else {
          suggestions.style.display = "none";
        }
      });

      // ファイル名を直接変更
      terminal.addEventListener("dblclick", (e) => {
        const fileDisplay = e.target.closest('.file-name-display');
        if (fileDisplay) {
          const oldName = fileDisplay.dataset.filename;
          const node = getNode(cwd);
          const item = node.children[oldName];
          if (item) {
            enableRename(fileDisplay, oldName);
          }
        }
      });

      // UIボタンのイベントリスナー
      helpBtn.addEventListener("click", () => {
        overlay.classList.remove("hidden");
      });
      closeBtn.addEventListener("click", () => {
        overlay.classList.add("hidden");
        input.focus();
      });
      themeBtn.addEventListener("click", () => {
        currentTheme = (currentTheme + 1) % themeKeys.length;
        applyTheme();
      });
      exportZipBtn.addEventListener("click", exportZip);
      importZipBtn.addEventListener("click", importZip);
      clearBtn.addEventListener("click", () => {
        processCommand("clear");
      });

      // エディタボタン
      btnSave.addEventListener("click", () => {
        if (currentEditFile) {
          const node = getNode(cwd);
          const file = node.children[currentEditFile];
          if (file) {
            file.content = editorText.value;
            setFileDates(file, false);
            saveVFS();
            print(`✅ ファイル '${currentEditFile}' を保存しました`, "success");
          }
        }
        closeEditor();
      });

      btnCancel.addEventListener("click", () => {
        closeEditor();
      });

      // 初期化
      applyTheme();
      updatePrompt();
      updateFileCount();
      print("=== Enhanced Web CLI ===", "info");
      print("タイプ 'help' でコマンド一覧を表示します。", "info");
      input.focus();
    });
  </script>
</body>
</html>
