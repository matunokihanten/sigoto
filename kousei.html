<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8"/>
  <title>ğŸŒŸ å®Œå…¨ç‰ˆæ§‹é€ ã‚¨ãƒ‡ã‚£ã‚¿ï¼‹è±ªè¯PDF/CSV/FS/ZIP</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; background: #f9f9f9; }
    #controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, auto)); /* Adjust for better button layout */
      gap: 8px;
      margin-bottom: 1rem;
    }
    #controls > * { font-size: 0.9rem; padding: 6px 12px; }
    #tree { list-style: none; padding-left: 0; }
    li { margin: 4px 0; position: relative; }
    li::before {
      content: ""; position: absolute; top: 12px; left: -10px;
      width: 10px; height: 1px; background: #ccc;
    }
    .children {
      border-left: 1px solid #ccc; margin-left: 10px; padding-left: 10px;
    }
    .node, .node-input {
      display: inline-block; padding: 4px 8px;
      border: 1px solid #aaa; border-radius: 4px; background: #fff;
      font-family: monospace;
    }
    .node { cursor: move; }
    .node-input { padding: 2px 4px; width: auto; }
    .actions button { margin-left: 4px; font-size: 0.8rem; }
    .over > .node { background: #def; }
    /* .ui-node { opacity: 0.4; } */ /* Removed as UI node handling is mostly removed */
    #modal-bg {
      position: fixed; left:0; top:0; width:100vw; height:100vh;
      background: rgba(0,0,0,0.3); z-index: 1000; display: none;
      align-items: center; justify-content: center;
    }
    #modal {
      background: #fff; border-radius: 8px; padding: 24px; min-width: 400px;
      box-shadow: 0 4px 24px #0002;
    }
    #modal textarea {
      width: 100%; height: 500px; font-family: monospace; font-size: 1rem;
      margin-bottom: 1em;
    }
    #modal label { font-weight: bold; }
    #modal .modal-btns { text-align: right; }
    #modal .modal-btns button { margin-left: 10px; }
    #fav-list { margin: 0 0 1em 0; }
    #fav-list button { margin-right: 6px; }
    /* #filter-ui { margin-left: 1em; } */ /* Removed as UI node handling is mostly removed */
    #txt-preview { white-space: pre; background: #fff; border: 1px solid #ccc; padding: 1em; margin: 1em 0; }
  </style>
</head>
<body>
  <h2>ğŸ—‚ï¸ å®Œå…¨ç‰ˆæ§‹é€ ã‚¨ãƒ‡ã‚£ã‚¿ãƒ»CSVä¿å­˜/èª­è¾¼ãƒ»FSèª­è¾¼ãƒ»ZIPãƒ»è±ªè¯PDFãƒ»SVGãƒ»ãƒ—ãƒªã‚»ãƒƒãƒˆ</h2>
  <div id="controls">
    <select id="templateSelect">
      <option value="empty">â€” ç©º â€”</option>
      <option value="js">JavaScript ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ</option>
      <option value="html">HTML ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ</option>
    </select>
    <button id="addRootFolder">ãƒ«ãƒ¼ãƒˆã«ãƒ•ã‚©ãƒ«ãƒ€è¿½åŠ </button>
    <button id="addRootFile">ãƒ«ãƒ¼ãƒˆã«ãƒ•ã‚¡ã‚¤ãƒ«è¿½åŠ </button>
    <button id="addRootTxt">ãƒ«ãƒ¼ãƒˆã«TXTè¿½åŠ </button>
    <button id="saveCsv">CSVã‚’ä¿å­˜</button>
    <button id="loadCsv">CSVã‚’èª­è¾¼</button>
    <button id="importFs">ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰èª­è¾¼</button>
    <button id="downloadZip">ZIPã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
    <button id="downloadSvg">SVGå‡ºåŠ›</button>
    <button id="txtPreviewBtn">TXTãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
    <button id="undoBtn">å…ƒã«æˆ»ã™</button>
    <button id="redoBtn">ã‚„ã‚Šç›´ã—</button>
    <button id="saveAllBtn">å…¨ä¿å­˜</button>
    <button id="loadAllBtn">å…¨èª­è¾¼</button>
    <button id="addFavBtn">ãŠæ°—ã«å…¥ã‚Šä¿å­˜</button>
    <button id="clearAllBtn">å…¨ã¦å‰Šé™¤</button> </div>
  <div id="fav-list"></div>
  <ul id="tree"></ul>
  <div id="txt-preview" style="display:none"></div>

  <div id="modal-bg">
    <div id="modal">
      <label id="modal-label"></label>
      <textarea id="modal-text"></textarea>
      <div class="modal-btns">
        <button id="modal-cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="modal-ok">ä¿å­˜</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script>
    //â€•â€• ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ â€•â€•
    const templates = {
      empty: ``,
      js: `
/my-app
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.js
â”œâ”€â”€ package.json
â””â”€â”€ README.md`.trim(),
      html: `
/site
â”œâ”€â”€ index.html
â”œâ”€â”€ style.css
â””â”€â”€ script.js`.trim()
    };

    //â€•â€• ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ â€•â€•
    let idCounter = 1;
    function genId() { return 'n'+(idCounter++); }
    function createNode(name,type){ return { id:genId(), name, type, children: [], content: '' }; } // uiNode removed
    function getFileTemplate(name){
      if(name.endsWith('.html')){
        const t=name.replace(/\.html$/,'');
        return `<!DOCTYPE html>
<html lang="ja">
<head><meta charset="UTF-8"><title>${t}</title></head>
<body>

</body>
</html>`;
      }
      return '';
    }

    //â€•â€• Undo/Redoç”¨å±¥æ­´ç®¡ç† â€•â€•
    let history = [];
    let future = [];
    function saveHistory(){
      history.push(JSON.stringify(root));
      if(history.length>100) history.shift();
      future = [];
      updateUndoRedoBtn();
    }
    function undo(){
      if(history.length===0) return;
      future.push(JSON.stringify(root));
      root = JSON.parse(history.pop());
      idCounter = getMaxId(root)+1;
      render();
      updateUndoRedoBtn();
    }
    function redo(){
      if(future.length===0) return;
      history.push(JSON.stringify(root));
      root = JSON.parse(future.pop());
      idCounter = getMaxId(root)+1;
      render();
      updateUndoRedoBtn();
    }
    function getMaxId(node){
      let max = 0;
      function walk(n){
        const num = parseInt(n.id.replace('n',''),10);
        if(num>max) max=num;
        n.children.forEach(walk);
      }
      // Root node's ID is "n" + idCounter, so we need to check it too
      const rootNum = parseInt(node.id.replace('n', ''), 10);
      if (rootNum > max) max = rootNum;
      node.children.forEach(walk);
      return max;
    }
    function updateUndoRedoBtn(){
      document.getElementById('undoBtn').disabled = history.length <= 1; // Disable if only initial state
      document.getElementById('redoBtn').disabled = future.length === 0;
    }

    //â€•â€• ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ â€•â€•
    let root = createNode('/', 'folder');
    let editingId = null;
    // let clipboard = null; // DELETED
    // let clipboardType = null; // 'copy' or 'cut' // DELETED
    let draggedId = null; // Defined here for clarity

    //â€•â€• ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆèª­ã¿è¾¼ã¿ â€•â€•
    function loadTemplate(key){
      root = createNode('/', 'folder');
      idCounter = 1; editingId = null;
      if(key!=='empty'){
        const lines=templates[key].split('\n'), stack=[];
        lines.forEach(raw=>{
          const depth=(raw.match(/^(\s*[â”‚â”œâ””â”€]+)?/)?.[0]||'')
            .replace(/[â”‚â”œâ””â”€]/g,'').length/2;
          const txt=raw.replace(/^[\sâ”‚â”œâ””â”€]+/,'').trim();
          if(!txt) return;
          const isDir=txt.endsWith('/');
          const name=txt.replace(/\/$/,'');
          const node=createNode(name,isDir?'folder':'file');
          while(stack.length>depth) stack.pop();
          const parent=stack[stack.length-1]||root;
          parent.children.push(node);
          if(isDir) stack.push(node);
        });
      }
      saveHistory();
      render();
    }

    //â€•â€• ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ç·¨é›†ç”¨ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ï¼‰
    let modalNode = null;
    function editFileContent(node) {
      modalNode = node;
      document.getElementById('modal-label').textContent = `ã€Œ${node.name}ã€ã®å†…å®¹ã‚’ç·¨é›†`;
      document.getElementById('modal-text').value = node.content || '';
      document.getElementById('modal-bg').style.display = 'flex';
      document.getElementById('modal-text').focus();
    }
    document.getElementById('modal-cancel').onclick = ()=>{
      document.getElementById('modal-bg').style.display = 'none';
      modalNode = null;
    };
    document.getElementById('modal-ok').onclick = ()=>{
      if(modalNode){
        modalNode.content = document.getElementById('modal-text').value;
        saveHistory();
        render();
      }
      document.getElementById('modal-bg').style.display = 'none';
      modalNode = null;
    };

    //â€•â€• ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° â€•â€•
    function render(){
      const ul=document.getElementById('tree');
      ul.innerHTML='';
      function build(node, container){
        node.children.forEach((ch, idx)=>{
          const li=document.createElement('li');
          li.draggable=true;
          li.dataset.id=ch.id;
          li.dataset.index = idx; // Store index for reordering
          li.dataset.parentId = node.id; // Store parent ID for drag & drop

          // if(ch.uiNode) li.classList.add('ui-node'); // Removed

          if(ch.id===editingId){
            const inp=document.createElement('input');
            inp.value=ch.name; inp.className='node-input';
            inp.onblur=()=>commitEdit(inp.value);
            inp.onkeydown=e=>{ if(e.key==='Enter') inp.blur(); };
            li.appendChild(inp);
            setTimeout(()=>inp.select(),0);
          } else {
            const sp=document.createElement('span');
            sp.className='node';
            sp.textContent=ch.name+(ch.type==='folder'?'/':''); // Show / for folders
            sp.ondblclick=()=>{ editingId=ch.id; render(); };
            // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ç·¨é›†
            if(ch.type==='file'){
              sp.style.cursor = 'pointer';
              sp.onclick = (e) => {
                e.stopPropagation();
                editFileContent(ch);
              };
            }
            li.appendChild(sp);
          }

          const act=document.createElement('span');
          act.className='actions';
          const btns=[
            {t:'âœ',fn:()=>{ editingId=ch.id; render(); }},
            {t:'+F',fn:()=>{ ch.children.push(createNode('æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€','folder')); saveHistory(); render(); },cond:ch.type==='folder'},
            {t:'+f',fn:()=>{ ch.children.push(createNode('æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«.html','file')); saveHistory(); render(); }},
            {t:'+t',fn:()=>{ ch.children.push(createNode('æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«.txt','file')); saveHistory(); render(); },cond:ch.type==='folder'},
            {t:'âœ•',fn:()=>{ removeNode(root,ch.id); saveHistory(); render(); }}
            // {t:'ğŸ“‹',fn:()=>{ clipboard=JSON.parse(JSON.stringify(ch)); clipboardType='copy'; },cond:true}, // DELETED
            // {t:'ğŸ“„',fn:()=>{ clipboard=JSON.parse(JSON.stringify(ch)); clipboardType='cut'; },cond:true} // DELETED
          ];
          btns.forEach(b=>{
            if(b.cond===false) return;
            const btn=document.createElement('button');
            btn.textContent=b.t; btn.onclick=b.fn;
            act.appendChild(btn);
          });
          li.appendChild(act);

          // Drag & Drop event listeners
          li.addEventListener('dragstart', onDragStart);
          li.addEventListener('dragover', onDragOver);
          li.addEventListener('dragleave', onDragLeave);
          li.addEventListener('drop', onDrop);
          li.addEventListener('dragenter', onDragEnter); // For visual feedback

          container.appendChild(li);
          if(ch.type==='folder'){
            const sub=document.createElement('ul');
            sub.className='children';
            li.appendChild(sub);
            build(ch,sub);
          }
        });
      }
      build(root,ul);
      updateUndoRedoBtn();
      renderFavList();
    }

    function commitEdit(val){
      if(val.trim()) findNode(root,editingId).name=val.trim();
      editingId=null; saveHistory(); render();
    }
    // å­å­«ãƒãƒ¼ãƒ‰ã‚‚æ­£ã—ãå‰Šé™¤
    function removeNode(p,id){
      if (p.id === id) { // If the node to remove is the root itself (shouldn't happen with current UI)
          root = createNode('/', 'folder');
          return true;
      }
      p.children = p.children.filter(c => c.id !== id);
      // Recursively check children of the current node's children (not the parent's children)
      for (const c of p.children) {
          removeNode(c, id);
      }
      return false;
    }
    function findNode(p,id){
      if(p.id===id) return p;
      for(const c of p.children){ const r=findNode(c,id); if(r) return r; }
    }
    function findParent(p,id){
      for(const c of p.children){
        if(c.id===id) return p;
        const r=findParent(c,id);
        if(r) return r;
      }
    }

    //â€•â€• Drag & Dropï¼ˆä¸¦ã¹æ›¿ãˆãƒ»ç§»å‹•ãƒã‚°ä¿®æ­£ï¼‰â€•â€•
    // let draggedId=null; // Already defined globally
    let dragTargetNode = null; // The target node being hovered over
    let dropPosition = 'inside'; // 'before', 'after', 'inside'

    function onDragStart(e) {
        draggedId = e.currentTarget.dataset.id;
        e.dataTransfer.effectAllowed = 'move';
        // Add a class to the dragged element to make it partially transparent
        e.currentTarget.classList.add('dragging');
    }

    function onDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        const targetLi = e.currentTarget;
        const targetNode = findNode(root, targetLi.dataset.id);
        const draggedNode = findNode(root, draggedId);

        if (!targetNode || !draggedNode || targetNode.id === draggedNode.id) {
            return;
        }

        // Prevent dropping a parent into its own child
        let currentCheck = targetNode;
        while (currentCheck) {
            if (currentCheck.id === draggedNode.id) {
                e.dataTransfer.dropEffect = 'none'; // Cannot drop
                return;
            }
            currentCheck = findParent(root, currentCheck.id);
        }

        const rect = targetLi.getBoundingClientRect();
        const y = e.clientY - rect.top;

        // Visual feedback for drop position
        targetLi.classList.remove('over', 'drop-before', 'drop-after');

        if (targetNode.type === 'folder' && y > rect.height / 4 && y < rect.height * 3 / 4) {
            // Drop inside folder
            dropPosition = 'inside';
            targetLi.classList.add('over'); // Highlight the folder node
        } else if (y < rect.height / 2) {
            // Drop before target
            dropPosition = 'before';
            targetLi.classList.add('drop-before'); // Add a class for top border
        } else {
            // Drop after target
            dropPosition = 'after';
            targetLi.classList.add('drop-after'); // Add a class for bottom border
        }
    }

    function onDragEnter(e) {
        // Clear previous visual feedback on all list items
        document.querySelectorAll('#tree li').forEach(li => {
            li.classList.remove('over', 'drop-before', 'drop-after');
        });
    }

    function onDragLeave(e) {
        // Clear visual feedback when leaving
        e.currentTarget.classList.remove('over', 'drop-before', 'drop-after');
    }

    function onDrop(e) {
        e.preventDefault();
        const targetLi = e.currentTarget;
        targetLi.classList.remove('over', 'drop-before', 'drop-after'); // Clear visual feedback
        document.querySelector('.dragging')?.classList.remove('dragging'); // Remove dragging class

        const draggedNode = findNode(root, draggedId);
        const sourceParent = findParent(root, draggedId);
        const targetNode = findNode(root, targetLi.dataset.id);

        if (!draggedNode || !sourceParent || !targetNode || draggedNode.id === targetNode.id) {
            return;
        }

        // Prevent dropping a parent into its own child
        let currentCheck = targetNode;
        while (currentCheck) {
            if (currentCheck.id === draggedNode.id) {
                return;
            }
            currentCheck = findParent(root, currentCheck.id);
        }

        // Remove from source
        sourceParent.children = sourceParent.children.filter(n => n.id !== draggedId);

        // Add to target
        if (dropPosition === 'inside' && targetNode.type === 'folder') {
            targetNode.children.push(draggedNode);
        } else {
            const targetParent = findParent(root, targetNode.id);
            if (targetParent) {
                const targetIndex = targetParent.children.findIndex(n => n.id === targetNode.id);
                if (dropPosition === 'before') {
                    targetParent.children.splice(targetIndex, 0, draggedNode);
                } else { // 'after'
                    targetParent.children.splice(targetIndex + 1, 0, draggedNode);
                }
            } else {
                // Should not happen for root level items, but as a fallback
                root.children.push(draggedNode);
            }
        }
        draggedId = null;
        saveHistory();
        render();
    }

    // CSS for drag-and-drop visual feedback
    const style = document.createElement('style');
    style.innerHTML = `
        .drop-before { border-top: 2px solid #4D96FF !important; }
        .drop-after { border-bottom: 2px solid #4D96FF !important; }
        .dragging { opacity: 0.5; }
    `;
    document.head.appendChild(style);


    //â€•â€• ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆæ©Ÿèƒ½ ï¼ˆDELETEDï¼‰â€•â€•
    /*
    document.getElementById('copyBtn').onclick=()=>{
      const sel = document.querySelector('.node.selected');
      if(!sel) return alert('ã‚³ãƒ”ãƒ¼ã—ãŸã„ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼ˆãƒãƒ¼ãƒ‰åã‚’ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼‰');
      const id = sel.parentElement.dataset.id;
      clipboard = JSON.parse(JSON.stringify(findNode(root,id)));
      clipboardType = 'copy';
    };
    document.getElementById('pasteBtn').onclick=()=>{
      if(!clipboard) return alert('ã‚³ãƒ”ãƒ¼ã¾ãŸã¯ã‚«ãƒƒãƒˆã—ãŸãƒãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“');
      const sel = document.querySelector('.node.selected');
      let parent = root;
      if(sel) {
        const id = sel.parentElement.dataset.id;
        const node = findNode(root,id);
        if(node.type==='folder') parent = node;
        else parent = findParent(root,id);
      }
      // æ–°ã—ã„IDã‚’æŒ¯ã‚Šç›´ã™
      function reid(n){
        n.id = genId();
        n.children.forEach(reid);
      }
      const pasted = JSON.parse(JSON.stringify(clipboard));
      reid(pasted);
      parent.children.push(pasted);
      saveHistory();
      render();
    };

    // ãƒãƒ¼ãƒ‰é¸æŠï¼ˆã‚³ãƒ”ãƒ¼ç”¨ï¼‰
    document.addEventListener('dblclick',e=>{
      document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected'));
      if(e.target.classList.contains('node')) e.target.classList.add('selected');
    });
    */

    //â€•â€• CSV ä¿å­˜/èª­è¾¼ï¼ˆUIãƒãƒ¼ãƒ‰é™¤å¤–ï¼‰â€•â€•
    function treeToCsv(){
      const rows=[['path','type','content']];
      (function w(n,p){
        n.children.forEach(c=>{
          // if(!document.getElementById('includeUiNode').checked && c.uiNode) return; // Removed
          const path=p+'/'+c.name;
          rows.push([path,c.type,c.type==='file'?btoa(unescape(encodeURIComponent(c.content||''))):'']);
          if(c.type==='folder') w(c,path);
        });
      })(root,'');
      return rows.map(r=>r.map(x=>`"${x.replace(/"/g,'""')}"`).join(',')).join('\n');
    }
    function saveCsv(){
      const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
      const csv = treeToCsv();
      const blob = new Blob([bom, csv], {type:'text/csv'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='structure.csv';
      a.click();
    }
    async function loadCsv(){
      const [f]=await window.showOpenFilePicker({types:[{accept:{'text/csv':['.csv']}}]});
      const txt=await (await f.getFile()).text();
      const lines=txt.split('\n').filter(l=>l.trim());
      root=createNode('/','folder'); // Reset root for new CSV
      idCounter = 1; // Reset ID counter
      lines.slice(1).forEach(l=>{
        // Handle lines that might contain quoted commas correctly
        const parts = [];
        let inQuote = false;
        let currentPart = '';
        for (let i = 0; i < l.length; i++) {
            const char = l[i];
            if (char === '"') {
                if (i + 1 < l.length && l[i+1] === '"') { // Escaped quote
                    currentPart += '"';
                    i++;
                } else {
                    inQuote = !inQuote;
                }
            } else if (char === ',' && !inQuote) {
                parts.push(currentPart);
                currentPart = '';
            } else {
                currentPart += char;
            }
        }
        parts.push(currentPart); // Add the last part

        if (parts.length < 3) return; // Skip malformed lines

        const path = parts[0].replace(/""/g,'"').replace(/^"|"$/g, ''); // Remove quotes
        const type = parts[1].replace(/""/g,'"').replace(/^"|"$/g, '');
        const content = parts[2] ? decodeURIComponent(escape(atob(parts[2].replace(/""/g,'"')
            .replace(/^"|"$/g, '')))) : ''; // Decode and remove quotes

        const seg=path.split('/').filter(Boolean);
        let p=root;
        seg.forEach((n,i)=>{
          const last=i===seg.length-1;
          if(last&&type==='file') {
            const newNode = createNode(n,'file');
            newNode.content = content; // Assign content here
            p.children.push(newNode);
          }
          else {
            let d=p.children.find(c=>c.name===n&&c.type==='folder');
            if(!d){ d=createNode(n,'folder'); p.children.push(d); }
            p=d;
          }
        });
      });
      saveHistory();
      render();
    }

    //â€•â€• ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰èª­è¾¼ â€•â€•
    async function importFs(){
      const dh=await window.showDirectoryPicker();
      idCounter=1;
      root=createNode('/','folder'); // Reset root
      await readFsRecursive(dh, root);
      saveHistory();
      render();
    }
    async function readFsRecursive(dh, parentNode){
      for await(const [name,ent] of dh.entries()){
        if(ent.kind==='directory') {
          const folderNode = createNode(name,'folder');
          parentNode.children.push(folderNode);
          await readFsRecursive(ent, folderNode);
        } else {
          const fileNode = createNode(name,'file');
          parentNode.children.push(fileNode);
          try {
            const file = await ent.getFile();
            fileNode.content = await file.text();
          } catch (e) {
            console.error(`Failed to read file ${name}:`, e);
            fileNode.content = `ERROR: Could not read file content. (${e.message})`;
          }
        }
      }
    }

    //â€•â€• ZIP å‡ºåŠ› â€•â€•
    function downloadZip(){
      const zip=new JSZip();
      (async function add(n,f){
        for (const c of n.children) { // Use for...of for async inside
          // if(!document.getElementById('includeUiNode').checked && c.uiNode) return; // Removed
          if(c.type==='folder') {
            await add(c,f.folder(c.name));
          } else {
            f.file(c.name, c.content ?? getFileTemplate(c.name));
          }
        }
      })(root,zip).then(()=>{ // Ensure all async operations are complete before generating
        zip.generateAsync({type:'blob'}).then(b=>{
          const a=document.createElement('a');
          a.href=URL.createObjectURL(b);
          a.download='structure.zip';
          a.click();
        });
      });
    }

    //â€•â€• TXTãƒ•ã‚¡ã‚¤ãƒ«è¿½åŠ ãƒœã‚¿ãƒ³
    document.getElementById('addRootTxt').onclick=()=>{
      root.children.push(createNode('æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«.txt','file'));
      saveHistory();
      render();
    };

    //â€•â€• æ§‹æˆå›³PDFï¼ˆDELETEDï¼‰â€•â€•
    /*
    async function downloadPdf(){
      const { jsPDF } = window.jspdf;
      const pdf=new jsPDF({unit:'pt',format:'a4'});
      const w=pdf.internal.pageSize.getWidth();
      const h=pdf.internal.pageSize.getHeight();
      const margin=40, nodeH=40, indentX=140, spaceY=24;
      const palette=['#FF6B6B','#6BCB77','#4D96FF','#FFD93D','#845EC2','#00C9A7','#F9A602'];
      const counts={}, all=[];

      function layout(n,d=0){
        n.children.forEach(c=>{
          // if(!document.getElementById('includeUiNode').checked && c.uiNode) return; // Removed
          if(!counts[d]) counts[d]=0;
          c.depth=d;
          c.x=margin + d*indentX;
          c.y=margin + counts[d]*(nodeH+spaceY) + (d===0?0:60);
          counts[d]++;
          all.push(c);
          layout(c,d+1);
        });
      }
      layout(root);

      // Canvas æº–å‚™
      const cv=document.createElement('canvas');
      cv.width=w; cv.height=h;
      const ctx=cv.getContext('2d');
      ctx.font='16px sans-serif';
      ctx.textBaseline='middle';

      // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
      const grad=ctx.createLinearGradient(0,0,0,h);
      grad.addColorStop(0,'#f0f4f8');
      grad.addColorStop(1,'#e0e7ef');
      ctx.fillStyle=grad;
      ctx.fillRect(0,0,w,h);

      // ç·šï¼ˆå¤ªããƒ»å½±ä»˜ãï¼‰
      ctx.save();
      ctx.shadowColor = "#bbb";
      ctx.shadowBlur = 6;
      ctx.strokeStyle='#555'; ctx.lineWidth=3;
      all.forEach(n=>{
        n.children.forEach(c=>{
          // if(!document.getElementById('includeUiNode').checked && c.uiNode) return; // Removed
          const x1=n.x + 110, y1=n.y + nodeH/2;
          const x2=c.x, y2=c.y + nodeH/2;
          const cx=(x1+x2)/2, cy=(y1+y2)/2 - 30;
          ctx.beginPath();
          ctx.moveTo(x1,y1);
          ctx.bezierCurveTo(cx,cy,cx,cy,x2,y2);
          ctx.stroke();
        });
      });
      ctx.restore();

      // ãƒãƒ¼ãƒ‰æç”»ï¼ˆã‚¢ã‚¤ã‚³ãƒ³ä»˜ãã‚«ãƒ¼ãƒ‰é¢¨ï¼‰
      all.forEach(n=>{
        const col=palette[n.depth % palette.length];
        const txt=n.name;
        const tw=ctx.measureText(txt).width;
        const bw=Math.max(tw+60,120), bh=nodeH;
        const x=n.x, y=n.y;
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.18)";
        ctx.shadowBlur = 8;
        roundRect(ctx,x+3,y+3,bw,bh,10);
        ctx.fillStyle='rgba(0,0,0,0.08)';
        ctx.fill();
        ctx.restore();
        const lg=ctx.createLinearGradient(x,y,x+bw,y+bh);
        lg.addColorStop(0,hexToRGBA(col,0.85));
        lg.addColorStop(1,hexToRGBA(col,1));
        ctx.fillStyle=lg;
        ctx.strokeStyle=shadeColor(col,-30);
        roundRect(ctx,x,y,bw,bh,10);
        ctx.fill();
        ctx.stroke();
        ctx.save();
        ctx.translate(x+24, y+bh/2);
        if(n.type==='folder'){
          drawFolderIcon(ctx);
        }else{
          drawFileIcon(ctx, n.name);
        }
        ctx.restore();
        ctx.fillStyle='#fff';
        ctx.font='bold 16px sans-serif';
        ctx.textAlign='left';
        ctx.fillText(txt,x+48,y+bh/2);
      });

      const img=cv.toDataURL('image/png');
      pdf.addImage(img,'PNG',0,0,w,h);
      pdf.save('structure_map.pdf');
    }
    */

    //â€•â€• å…¨å†…å®¹PDFï¼ˆDELETEDï¼‰â€•â€•
    /*
    async function downloadFullPdf(){
      const { jsPDF } = window.jspdf;
      const pdf=new jsPDF({unit:'pt',format:'a4'});
      let y=40, margin=40, lineH=18, pageH=pdf.internal.pageSize.getHeight();

      function addLine(txt, bold=false){
        if(y>pageH-40) { pdf.addPage(); y=40; }
        pdf.setFont('helvetica', bold?'bold':'normal');
        pdf.setFontSize(bold?13:11);
        pdf.text(txt, margin, y, {encoding:'Identity-H'});
        y+=lineH;
      }
      function walk(n, prefix=''){
        n.children.forEach(c=>{
          // if(!document.getElementById('includeUiNode').checked && c.uiNode) return; // Removed
          addLine(prefix+c.name+(c.type==='folder'?'/':''), true);
          if(c.type==='file' && c.content){
            c.content.split(/\r?\n/).forEach(line=>{
              addLine('ã€€'+line);
            });
          }
          if(c.type==='folder') walk(c, prefix+'ã€€');
        });
      }
      addLine('ã€æ§‹æˆã¨å†…å®¹ã€‘', true);
      walk(root);
      pdf.save('structure_full.pdf');
    }
    */

    //â€•â€• SVGå‡ºåŠ›ï¼ˆUIãƒãƒ¼ãƒ‰é™¤å¤–ï¼‰â€•â€•
    document.getElementById('downloadSvg').onclick=()=>{
      const w=1200, h=800, margin=40, nodeH=40, indentX=140, spaceY=24;
      const palette=['#FF6B6B','#6BCB77','#4D96FF','#FFD93D','#845EC2','#00C9A7','#F9A602'];
      const counts={}, all=[];
      function layout(n,d=0){
        n.children.forEach(c=>{
          // if(!document.getElementById('includeUiNode').checked && c.uiNode) return; // Removed
          if(!counts[d]) counts[d]=0;
          c.depth=d;
          c.x=margin + d*indentX;
          c.y=margin + counts[d]*(nodeH+spaceY) + (d===0?0:60);
          counts[d]++;
          all.push(c);
          layout(c,d+1);
        });
      }
      layout(root);
      let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" style="background:#f0f4f8">`;
      all.forEach(n=>{
        n.children.forEach(c=>{
          // if(!document.getElementById('includeUiNode').checked && c.uiNode) return; // Removed
          const x1=n.x + 110, y1=n.y + nodeH/2;
          const x2=c.x, y2=c.y + nodeH/2;
          const cx=(x1+x2)/2, cy=(y1+y2)/2 - 30;
          svg+=`<path d="M${x1},${y1} C${cx},${cy} ${cx},${cy} ${x2},${y2}" stroke="#555" stroke-width="3" fill="none" />`;
        });
      });
      all.forEach(n=>{
        const col=palette[n.depth % palette.length];
        const txt=n.name;
        // Adjust bw based on text width for better fit, but keep min for icons
        const tempCtx = document.createElement('canvas').getContext('2d');
        tempCtx.font = 'bold 16px sans-serif'; // Must match SVG font for accurate measurement
        const tw = tempCtx.measureText(txt).width;
        const bw = Math.max(tw + 60, 120); // Min width 120, plus padding for text/icon
        const x=n.x, y=n.y;
        svg+=`<rect x="${x}" y="${y}" rx="10" ry="10" width="${bw}" height="${nodeH}" fill="${col}" stroke="#333" stroke-width="2"/>`;
        
        // Add icon based on type
        if (n.type === 'folder') {
            svg += `
                <g transform="translate(${x + 24}, ${y + nodeH / 2})">
                    <path d="M-14,6 L-10,-8 L18,-8 L14,6 Z" fill="#fff8e1" stroke-width="0"/>
                    <path d="M-16,8 L16,8 L14,16 L-14,16 Z" fill="#ffe082" stroke-width="0"/>
                </g>
            `;
        } else { // File
            const fileExt = n.name.split('.').pop().toUpperCase();
            svg += `
                <g transform="translate(${x + 24}, ${y + nodeH / 2})">
                    <rect x="-12" y="-12" width="24" height="24" fill="#fff" stroke="#bbb" stroke-width="1"/>
                    <text x="0" y="2" font-size="10" fill="#888" font-family="monospace" text-anchor="middle">${fileExt}</text>
                </g>
            `;
        }
        svg+=`<text x="${x+48}" y="${y+nodeH/2+6}" font-size="16" fill="#fff" font-family="sans-serif" font-weight="bold">${txt}</text>`; // Changed to sans-serif for consistency
      });
      svg+='</svg>';
      const blob = new Blob([svg], {type:'image/svg+xml'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='structure.svg';
      a.click();
    };

    //â€•â€• TXTãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆUIãƒãƒ¼ãƒ‰é™¤å¤–ï¼‰â€•â€•
    document.getElementById('txtPreviewBtn').onclick=()=>{
      let txt = '';
      function walk(n, prefix=''){
        n.children.forEach(c=>{
          // if(!document.getElementById('includeUiNode').checked && c.uiNode) return; // Removed
          txt += prefix + c.name + (c.type==='folder'?'/':'') + '\n';
          if(c.type==='file' && c.content){
            txt += c.content.split(/\r?\n/).map(line=>'ã€€'+line).join('\n')+'\n';
          }
          if(c.type==='folder') walk(c, prefix+'ã€€');
        });
      }
      walk(root);
      document.getElementById('txt-preview').textContent = txt;
      document.getElementById('txt-preview').style.display = 'block';
    };

    // ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆThese functions are not used directly anymore, replaced by SVG inline for SVG outputï¼‰
    function drawFolderIcon(ctx){ /* ... */ }
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¤ã‚³ãƒ³
    function drawFileIcon(ctx, name){ /* ... */ }

    // Helper functions for PDF/SVG (not directly used by main logic now)
    function roundRect(ctx,x,y,w,h,r){ /* ... */ }
    function hexToRGBA(hex,a){ /* ... */ }
    function shadeColor(col,amt){ /* ... */ }

    //â€•â€• å®Œå…¨ä¿å­˜ãƒ»èª­è¾¼ï¼ˆJSONï¼‰â€•â€•
    document.getElementById('saveAllBtn').onclick=()=>{
      const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
      const blob = new Blob([bom, JSON.stringify(root, null, 2)], {type:'application/json'}); // Pretty print JSON
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='structure.json';
      a.click();
    };
    document.getElementById('loadAllBtn').onclick=async()=>{
      const [f]=await window.showOpenFilePicker({types:[{accept:{'application/json':['.json']}}]});
      const txt=await (await f.getFile()).text();
      try {
        root=JSON.parse(txt);
        idCounter = getMaxId(root)+1;
        saveHistory();
        render();
      } catch (e) {
        alert('JSONãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒç ´æã—ã¦ã„ã‚‹ã‹ã€å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚');
        console.error('JSON load error:', e);
      }
    };

    //â€•â€• ãŠæ°—ã«å…¥ã‚Šãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¿å­˜ãƒ»å‘¼ã³å‡ºã— â€•â€•
    function renderFavList(){
      const favDiv = document.getElementById('fav-list');
      favDiv.innerHTML = '';
      const favs = JSON.parse(localStorage.getItem('favTemplates')||'[]');
      favs.forEach((f,i)=>{
        const btnContainer = document.createElement('span');
        const btn = document.createElement('button');
        btn.textContent = f.name;
        btn.onclick = ()=>{
          root = JSON.parse(f.data);
          idCounter = getMaxId(root)+1;
          saveHistory();
          render();
        };
        btnContainer.appendChild(btn);

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'âœ•';
        deleteBtn.className = 'delete-fav-btn';
        deleteBtn.title = 'ãŠæ°—ã«å…¥ã‚Šã‚’å‰Šé™¤';
        deleteBtn.onclick = (e) => {
            e.stopPropagation(); // Prevent loading the favorite
            if (confirm(`ãŠæ°—ã«å…¥ã‚Šã€Œ${f.name}ã€ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`)) {
                removeFav(i);
            }
        };
        btnContainer.appendChild(deleteBtn);
        favDiv.appendChild(btnContainer);
      });
    }

    function removeFav(index){
        const favs = JSON.parse(localStorage.getItem('favTemplates')||'[]');
        favs.splice(index, 1);
        localStorage.setItem('favTemplates', JSON.stringify(favs));
        renderFavList();
    }

    document.getElementById('addFavBtn').onclick=()=>{
      const name = prompt('ãŠæ°—ã«å…¥ã‚Šãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      if(!name) return;
      const favs = JSON.parse(localStorage.getItem('favTemplates')||'[]');
      favs.push({name, data: JSON.stringify(root)});
      localStorage.setItem('favTemplates', JSON.stringify(favs));
      renderFavList();
    };

    //â€•â€• å…¨ã¦å‰Šé™¤ãƒœã‚¿ãƒ³ â€•â€•
    document.getElementById('clearAllBtn').onclick = () => {
        if (confirm('å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨ãƒ•ã‚©ãƒ«ãƒ€ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚')) {
            root = createNode('/', 'folder');
            idCounter = 1;
            saveHistory();
            render();
        }
    };

    //â€•â€• ãƒœã‚¿ãƒ³ãƒã‚¤ãƒ³ãƒ‰ & åˆæœŸãƒ¬ãƒ³ãƒ€ãƒ¼ â€•â€•
    document.getElementById('templateSelect').onchange=e=>loadTemplate(e.target.value);
    document.getElementById('addRootFolder').onclick=()=>{ root.children.push(createNode('æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€','folder')); saveHistory(); render(); };
    document.getElementById('addRootFile').onclick=()=>{ root.children.push(createNode('æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«.html','file')); saveHistory(); render(); };
    document.getElementById('saveCsv').onclick=saveCsv;
    document.getElementById('loadCsv').onclick=loadCsv;
    document.getElementById('importFs').onclick=importFs;
    document.getElementById('downloadZip').onclick=downloadZip;
    // document.getElementById('downloadPdf').onclick=downloadPdf; // DELETED
    // document.getElementById('downloadFullPdf').onclick=downloadFullPdf; // DELETED
    document.getElementById('undoBtn').onclick=undo;
    document.getElementById('redoBtn').onclick=redo;

    // Initial render and history save
    render();
    saveHistory(); // Save the initial empty state
  </script>
</body>
</html>
