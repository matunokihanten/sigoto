<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8"/>
  <title>🌟 完全版構造エディタ＋豪華PDF/CSV/FS/ZIP</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; background: #f9f9f9; }
    #controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, auto));
      gap: 8px;
      margin-bottom: 1rem;
    }
    #controls > *, #color-picker > * { font-size: 0.9rem; padding: 6px 12px; }
    #color-picker {
        grid-column: 1 / -1; /* Take full width */
        border: 1px solid #ccc;
        padding: 8px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    #color-picker label { font-weight: bold; }
    #color-picker input[type="radio"] { margin-left: 2px; }
    #tree { list-style: none; padding-left: 0; }
    li { margin: 4px 0; position: relative; }
    li::before {
      content: ""; position: absolute; top: 12px; left: -10px;
      width: 10px; height: 1px; background: #ccc;
    }
    .children {
      border-left: 1px solid #ccc; margin-left: 10px; padding-left: 10px;
    }
    .node, .node-input {
      display: inline-block; padding: 4px 8px;
      border: 1px solid #aaa; border-radius: 4px; background: #fff;
      font-family: monospace;
      transition: background-color 0.3s;
    }
    .node { cursor: pointer; }
    .node.selected {
        outline: 2px solid #007bff;
        outline-offset: 1px;
    }
    .node-input { padding: 2px 4px; width: auto; }
    .actions button { margin-left: 4px; font-size: 0.8rem; }
    .over > .node { background: #def; }
    #modal-bg {
      position: fixed; left:0; top:0; width:100vw; height:100vh;
      background: rgba(0,0,0,0.3); z-index: 1000; display: none;
      align-items: center; justify-content: center;
    }
    #modal {
      background: #fff; border-radius: 8px; padding: 24px; min-width: 400px;
      box-shadow: 0 4px 24px #0002;
    }
    #modal textarea {
      width: 100%; height: 500px; font-family: monospace; font-size: 1rem;
      margin-bottom: 1em;
    }
    #modal label { font-weight: bold; }
    #modal .modal-btns { text-align: right; }
    #modal .modal-btns button { margin-left: 10px; }
    #fav-list { margin: 0 0 1em 0; }
    #fav-list button { margin-right: 6px; }
    #txt-preview { white-space: pre; background: #fff; border: 1px solid #ccc; padding: 1em; margin: 1em 0; }

    /* Drag & Drop Visual Feedback */
    .drop-before { border-top: 2px solid #4D96FF !important; }
    .drop-after { border-bottom: 2px solid #4D96FF !important; }
    .over > .node { background: #e0f2f7 !important; outline: 2px solid #4D96FF; outline-offset: 1px;}
    .dragging { opacity: 0.5; }

    /* PNG生成時にボタンを非表示にするためのスタイル */
    body.hide-for-capture .actions {
        display: none !important;
    }
  </style>
</head>
<body>
  <h2>🗂️ 完全版構造エディタ・CSV保存/読込・FS読込・ZIP・豪華PDF・画像・プリセット</h2>
  <div id="controls">
    <select id="templateSelect">
      <option value="empty">— 空 —</option>
      <option value="js">JavaScript プロジェクト</option>
      <option value="html">HTML ファイル構成</option>
    </select>
    <button id="addRootFolder">ルートにフォルダ追加</button>
    <button id="addRootFile">ルートにファイル追加</button>
    <button id="addRootTxt">ルートにTXT追加</button>
    <button id="saveCsv">CSVを保存</button>
    <button id="loadCsv">CSVを読込</button>
    <button id="importFs">フォルダから読込</button>
    <button id="downloadZip">ZIPをダウンロード</button>
    <button id="downloadPng">PNG画像でダウンロード</button>
    <button id="txtPreviewBtn">TXTプレビュー</button>
    <button id="undoBtn">元に戻す</button>
    <button id="redoBtn">やり直し</button>
    <button id="saveAllBtn">全保存</button>
    <button id="loadAllBtn">全読込</button>
    <button id="addFavBtn">お気に入り保存</button>
    <button id="clearAllBtn">全て削除</button>
    <div id="color-picker">
        <label>🎨 色:</label>
        <input type="radio" name="color" value="#FFFFFF" checked> 白
        <input type="radio" name="color" value="#ffdddd"> 赤
        <input type="radio" name="color" value="#ddffdd"> 緑
        <input type="radio" name="color" value="#ddddff"> 青
        <input type="radio" name="color" value="#ffffdd"> 黄
        <input type="radio" name="color" value="#ffddff"> 紫
        <input type="radio" name="color" value="#ddffff"> 水色
        <input type="radio" name="color" value="#f0f0f0"> 灰
    </div>
  </div>
  <div id="fav-list"></div>
  <ul id="tree"></ul>
  <div id="txt-preview" style="display:none"></div>

  <div id="modal-bg">
    <div id="modal">
      <label id="modal-label"></label>
      <textarea id="modal-text"></textarea>
      <div class="modal-btns">
        <button id="modal-cancel">キャンセル</button>
        <button id="modal-ok">保存</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <script>
    // --- interfaces.ts
    // TypeScriptの型定義をJavaScriptのコメントとして記述
    /**
     * @typedef {Object} Node
     * @property {string} id
     * @property {string} name
     * @property {'folder' | 'file'} type
     * @property {Node[]} children
     * @property {string} content
     * @property {string} color
     */

    /**
     * @typedef {Object} FavoriteTemplate
     * @property {string} name
     * @property {string} data
     */

    // --- utils.ts
    const getFileTemplate = (name) => {
      if (name.endsWith('.html')) {
        const t = name.replace(/\.html$/, '');
        return `<!DOCTYPE html>
<html lang="ja">
<head><meta charset="UTF-8"><title>${t}</title></head>
<body>

</body>
</html>`;
      }
      return '';
    };

    const getContrastYIQ = (hexcolor) => {
      const hex = hexcolor.replace("#", "");
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
      return (yiq >= 128) ? 'black' : 'white';
    };

    const findNode = (root, id) => {
      const stack = [root];
      while (stack.length > 0) {
        const node = stack.pop();
        if (node.id === id) {
          return node;
        }
        stack.push(...node.children);
      }
      return null;
    };

    const findParent = (root, id) => {
      const stack = [root];
      while (stack.length > 0) {
        const node = stack.pop();
        if (node.children.some(c => c.id === id)) {
          return node;
        }
        stack.push(...node.children);
      }
      return null;
    };

    const getMaxId = (node) => {
      let max = 0;
      const stack = node.children.slice();
      while (stack.length > 0) {
        const n = stack.pop();
        const num = parseInt(n.id.replace('n', ''), 10);
        if (num > max) {
          max = num;
        }
        stack.push(...n.children);
      }
      return max;
    };
    
    // --- templates.ts
    const templates = {
      empty: ``,
      js: `
/my-app
├── src/
│   └── index.js
├── package.json
└── README.md`.trim(),
      html: `
/site
├── index.html
├── style.css
└── script.js`.trim()
    };

    const loadTemplate = (key, createNodeFunc) => {
      const newRoot = createNodeFunc('/', 'folder');
      let idCounter = 1;
      const localCreateNode = (name, type, color = '#FFFFFF') => {
          return { id: `n${idCounter++}`, name, type, children: [], content: '', color };
      };
      if (key !== 'empty') {
        const lines = templates[key].split('\n');
        const stack = [];
        lines.forEach(raw => {
          const depth = (raw.match(/^(\s*[│├└─]+)?/)?.[0] || '').replace(/[│├└─]/g, '').length / 2;
          const txt = raw.replace(/^[\s│├└─]+/, '').trim();
          if (!txt) return;

          const isDir = txt.endsWith('/');
          const name = txt.replace(/\/$/, '');
          const node = localCreateNode(name, isDir ? 'folder' : 'file');

          while (stack.length > depth) {
            stack.pop();
          }

          const parent = stack[stack.length - 1] || newRoot;
          parent.children.push(node);
          if (isDir) {
            stack.push(node);
          }
        });
      }
      return newRoot;
    };

    // --- file-handlers.ts
    const treeToCsv = (root) => {
      const rows = [['path', 'type', 'content', 'color']];
      const walk = (node, pathPrefix) => {
        node.children.forEach(c => {
          const path = `${pathPrefix}/${c.name}`;
          const content = c.type === 'file' ? c.content || '' : '';
          const encodedContent = btoa(encodeURIComponent(content));
          rows.push([path, c.type, encodedContent, c.color || '#FFFFFF']);
          if (c.type === 'folder') {
            walk(c, path);
          }
        });
      };
      walk(root, '');
      return rows.map(r => r.map(x => `"${(x || '').replace(/"/g, '""')}"`).join(',')).join('\n');
    };

    const loadCsv = async (createNodeFunc) => {
      try {
        const [fileHandle] = await window.showOpenFilePicker({ types: [{ accept: { 'text/csv': ['.csv'] } }] });
        const file = await fileHandle.getFile();
        const text = await file.text();
        const lines = text.split('\n').filter(l => l.trim());
        const newRoot = createNodeFunc('/', 'folder');
        lines.slice(1).forEach(l => {
          const parts = l.match(/(".*?"|[^",\s]+)(?=\s*|\s*,|$)/g)?.map(p => p.replace(/^"|"$/g, '').replace(/""/g, '"')) || [];
          if (parts.length < 2) return;
          const [path, type, contentStr, color] = parts;
          let content = '';
          if (contentStr && type === 'file') {
            try {
              content = decodeURIComponent(atob(contentStr));
            } catch (e) {
              console.error('Failed to decode content from Base64:', e);
              content = '';
            }
          }
          const segments = path.split('/').filter(Boolean);
          let parent = newRoot;
          segments.forEach((segment, i) => {
            const isLast = i === segments.length - 1;
            const nodeType = isLast ? type : 'folder';
            let existingNode = parent.children.find(c => c.name === segment && c.type === nodeType);
            if (!existingNode) {
              existingNode = createNodeFunc(segment, nodeType, color);
              if (isLast && type === 'file') {
                existingNode.content = content;
              }
              parent.children.push(existingNode);
            }
            parent = existingNode;
          });
        });
        return newRoot;
      } catch (e) {
        if (e.name !== 'AbortError') {
          alert('CSVファイルの読み込みに失敗しました。');
        }
        return null;
      }
    };

    const downloadZip = (root) => {
      const zip = new JSZip();
      const add = (node, folder) => {
        node.children.forEach(child => {
          if (child.type === 'folder') {
            add(child, folder.folder(child.name));
          } else {
            folder.file(child.name, child.content || getFileTemplate(child.name));
          }
        });
      };
      add(root, zip);
      zip.generateAsync({ type: 'blob' }).then(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'structure.zip';
        a.click();
        URL.revokeObjectURL(a.href);
      });
    };

    const readFsRecursive = async (directoryHandle, parentNode, createNodeFunc) => {
      for await (const entry of (directoryHandle.values())) {
        if (entry.kind === 'directory') {
          const folderNode = createNodeFunc(entry.name, 'folder');
          parentNode.children.push(folderNode);
          await readFsRecursive(entry, folderNode, createNodeFunc);
        } else {
          const fileNode = createNodeFunc(entry.name, 'file');
          parentNode.children.push(fileNode);
          try {
            const file = await entry.getFile();
            fileNode.content = await file.text();
          } catch (e) {
            fileNode.content = `ERROR: ${e.message}`;
          }
        }
      }
    };

    // --- history-manager.ts
    class HistoryManager {
      constructor(initialState) {
        this.history = [];
        this.future = [];
        this.maxStates = 100;
        this.save(initialState);
      }
      save(state) {
        this.history.push(JSON.stringify(state));
        if (this.history.length > this.maxStates) {
          this.history.shift();
        }
        this.future = [];
      }
      undo() {
        if (this.history.length <= 1) return null;
        this.future.push(this.history.pop());
        return JSON.parse(this.history[this.history.length - 1]);
      }
      redo() {
        if (this.future.length === 0) return null;
        const nextState = this.future.pop();
        this.history.push(nextState);
        return JSON.parse(nextState);
      }
      canUndo() {
        return this.history.length > 1;
      }
      canRedo() {
        return this.future.length > 0;
      }
    }

    // --- app.ts
    class App {
      constructor() {
        this.idCounter = 1;
        this.root = this.createNode('/', 'folder');
        this.editingId = null;
        this.selectedId = null;
        this.draggedId = null;
        this.dropPosition = 'inside';
        this.historyManager = new HistoryManager(this.root);
        this.bindEvents();
        this.render();
      }

      createNode(name, type, color = '#FFFFFF') {
        return { id: `n${this.idCounter++}`, name, type, children: [], content: '', color };
      }

      render() {
        const ul = document.getElementById('tree');
        ul.innerHTML = '';
        const build = (node, container) => {
          node.children.forEach(ch => {
            const li = document.createElement('li');
            li.draggable = true;
            li.dataset.id = ch.id;

            const sp = document.createElement('span');
            sp.className = 'node';
            if (ch.id === this.selectedId) {
              sp.classList.add('selected');
            }
            sp.style.backgroundColor = ch.color;
            sp.style.color = getContrastYIQ(ch.color);
            sp.textContent = ch.name + (ch.type === 'folder' ? '/' : '');
            sp.onclick = (e) => this.handleNodeClick(e, ch);
            sp.ondblclick = () => this.startEditing(ch);
            li.appendChild(sp);
            
            const act = document.createElement('span');
            act.className = 'actions';
            const btns = [
                { t: '✎', fn: () => this.startEditing(ch) },
                { t: '+フォルダ', fn: () => this.addNode(ch, 'folder'), cond: ch.type === 'folder' },
                { t: '+html', fn: () => this.addNode(ch, 'file', '.html'), cond: ch.type === 'folder' },
                { t: '+txt', fn: () => this.addNode(ch, 'file', '.txt'), cond: ch.type === 'folder' },
                { t: '✕', fn: () => this.removeNode(ch) },
                { t: '📝', fn: () => this.editFileContent(ch), cond: ch.type === 'file' },
                { t: '▶', fn: () => this.executeHtmlFile(ch), cond: ch.type === 'file' && ch.name.endsWith('.html') }
            ];
            btns.forEach(b => {
                if (b.cond === false) return;
                const btn = document.createElement('button');
                btn.textContent = b.t; btn.onclick = b.fn;
                act.appendChild(btn);
            });
            li.appendChild(act);

            li.addEventListener('dragstart', (e) => this.onDragStart(e));
            li.addEventListener('dragover', (e) => this.onDragOver(e));
            li.addEventListener('dragleave', (e) => this.onDragLeave(e));
            li.addEventListener('drop', (e) => this.onDrop(e));
            li.addEventListener('dragend', (e) => this.onDragEnd(e));

            container.appendChild(li);
            if (ch.type === 'folder') {
              const sub = document.createElement('ul');
              sub.className = 'children';
              li.appendChild(sub);
              build(ch, sub);
            }
          });
        };
        build(this.root, ul);
        this.updateUndoRedoBtn();
        this.renderFavList();
      }

      handleNodeClick(e, node) {
          e.stopPropagation();
          this.selectedId = node.id;
          const selectedNode = findNode(this.root, this.selectedId);
          const colorRadios = document.querySelectorAll('#color-picker input[name="color"]');
          colorRadios.forEach(radio => {
              radio.checked = radio.value === (selectedNode.color || '#FFFFFF');
          });
          this.render();
      }

      startEditing(node) {
        this.editingId = node.id;
        this.selectedId = null;
        this.render();
      }

      commitEdit(val) {
        if (val.trim()) findNode(this.root, this.editingId).name = val.trim();
        this.editingId = null;
        this.saveStateAndRender();
      }

      saveStateAndRender() {
        this.historyManager.save(this.root);
        this.render();
      }

      addNode(parent, type, suffix = '') {
        const newNode = this.createNode(`新しい${type === 'folder' ? 'フォルダ' : 'ファイル'}${suffix}`, type, parent.color);
        parent.children.push(newNode);
        this.saveStateAndRender();
      }

      removeNode(node) {
        const parent = findParent(this.root, node.id);
        if (parent) {
          parent.children = parent.children.filter(c => c.id !== node.id);
          this.selectedId = null;
          this.saveStateAndRender();
        }
      }

      editFileContent(node) {
        this.modalNode = node;
        document.getElementById('modal-label').textContent = `「${node.name}」の内容を編集`;
        document.getElementById('modal-text').value = node.content || '';
        document.getElementById('modal-bg').style.display = 'flex';
        document.getElementById('modal-text').focus();
      }

      executeHtmlFile(node) {
        if (node.type === 'file' && node.name.endsWith('.html')) {
          const blob = new Blob([node.content], { type: 'text/html' });
          const url = URL.createObjectURL(blob);
          window.open(url, '_blank');
        } else {
          alert('これはHTMLファイルではありません。');
        }
      }

      updateUndoRedoBtn() {
        document.getElementById('undoBtn').disabled = !this.historyManager.canUndo();
        document.getElementById('redoBtn').disabled = !this.historyManager.canRedo();
      }

      onDragStart(e) {
        this.draggedId = e.currentTarget.dataset.id;
        e.dataTransfer.effectAllowed = 'move';
        e.currentTarget.classList.add('dragging');
      }

      onDragOver(e) {
        e.preventDefault();
        const targetLi = e.currentTarget;
        const targetId = targetLi.dataset.id;
        const targetNode = findNode(this.root, targetId);
        const draggedNode = findNode(this.root, this.draggedId);

        document.querySelectorAll('#tree li.over, #tree li.drop-before, #tree li.drop-after').forEach(li => {
          li.classList.remove('over', 'drop-before', 'drop-after');
        });

        if (!targetNode || !draggedNode || this.draggedId === targetId) {
          e.dataTransfer.dropEffect = 'none';
          return;
        }

        let current = targetNode;
        while(current) {
          if (current.id === this.draggedId) {
            e.dataTransfer.dropEffect = 'none';
            return;
          }
          current = findParent(this.root, current.id);
        }
        e.dataTransfer.dropEffect = 'move';

        const rect = targetLi.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const third = rect.height / 3;

        if (targetNode.type === 'folder') {
          if (y < third) {
            this.dropPosition = 'before';
            targetLi.classList.add('drop-before');
          } else if (y > third * 2) {
            this.dropPosition = 'after';
            targetLi.classList.add('drop-after');
          } else {
            this.dropPosition = 'inside';
            targetLi.classList.add('over');
          }
        } else {
          if (y < rect.height / 2) {
            this.dropPosition = 'before';
            targetLi.classList.add('drop-before');
          } else {
            this.dropPosition = 'after';
            targetLi.classList.add('drop-after');
          }
        }
      }

      onDragLeave(e) {
        e.currentTarget.classList.remove('over', 'drop-before', 'drop-after');
      }

      onDrop(e) {
        e.preventDefault();
        e.stopPropagation();

        document.querySelectorAll('#tree li.dragging, #tree li.over, #tree li.drop-before, #tree li.drop-after').forEach(li => {
          li.classList.remove('dragging', 'over', 'drop-before', 'drop-after');
        });

        const targetId = e.currentTarget.dataset.id;
        if (this.draggedId === targetId) return;

        const draggedNode = findNode(this.root, this.draggedId);
        if (!draggedNode) return;

        const sourceParent = findParent(this.root, this.draggedId);
        if (sourceParent) {
          sourceParent.children = sourceParent.children.filter(c => c.id !== this.draggedId);
        } else {
          this.draggedId = null;
          return;
        }

        const targetNode = findNode(this.root, targetId);
        if (!targetNode) return;

        if (this.dropPosition === 'inside' && targetNode.type === 'folder') {
          targetNode.children.push(draggedNode);
        } else {
          const targetParent = findParent(this.root, targetId);
          const parentToInsertInto = targetParent || this.root;
          const targetIndex = parentToInsertInto.children.findIndex(c => c.id === targetId);
          if (targetIndex > -1) {
            if (this.dropPosition === 'before') {
              parentToInsertInto.children.splice(targetIndex, 0, draggedNode);
            } else {
              parentToInsertInto.children.splice(targetIndex + 1, 0, draggedNode);
            }
          } else {
            parentToInsertInto.children.push(draggedNode);
          }
        }

        this.draggedId = null;
        this.saveStateAndRender();
      }

      onDragEnd(e) {
        document.querySelectorAll('#tree li.dragging, #tree li.over, #tree li.drop-before, #tree li.drop-after').forEach(li => {
          li.classList.remove('dragging', 'over', 'drop-before', 'drop-after');
        });
        this.draggedId = null;
      }

      updateChildrenColor(node, newColor) {
        node.children.forEach(child => {
            child.color = newColor;
            if (child.type === 'folder') {
                this.updateChildrenColor(child, newColor);
            }
        });
      }

      renderFavList() {
        const favDiv = document.getElementById('fav-list');
        favDiv.innerHTML = '<b>お気に入り: </b>';
        const favs = JSON.parse(localStorage.getItem('favTemplates') || '[]');
        favs.forEach((f, i) => {
          const btnContainer = document.createElement('span');
          const btn = document.createElement('button');
          btn.textContent = f.name;
          btn.onclick = () => {
            this.root = JSON.parse(f.data);
            this.idCounter = getMaxId(this.root) + 1;
            this.historyManager = new HistoryManager(this.root);
            this.render();
          };
          btnContainer.appendChild(btn);

          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = '✕';
          deleteBtn.title = 'お気に入りを削除';
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            if (confirm(`「${f.name}」を削除しますか？`)) { this.removeFav(i); }
          };
          btnContainer.appendChild(deleteBtn);
          favDiv.appendChild(btnContainer);
        });
      }

      removeFav(index) {
        const favs = JSON.parse(localStorage.getItem('favTemplates') || '[]');
        favs.splice(index, 1);
        localStorage.setItem('favTemplates', JSON.stringify(favs));
        this.renderFavList();
      }

      bindEvents() {
        document.getElementById('templateSelect').onchange = (e) => {
          this.root = loadTemplate(e.target.value, this.createNode.bind(this));
          this.idCounter = getMaxId(this.root) + 1;
          this.saveStateAndRender();
        };
        document.getElementById('addRootFolder').onclick = () => {
          this.root.children.push(this.createNode('新しいフォルダ', 'folder'));
          this.saveStateAndRender();
        };
        document.getElementById('addRootFile').onclick = () => {
          const newNode = this.createNode('新しいファイル.html', 'file');
          newNode.content = getFileTemplate(newNode.name);
          this.root.children.push(newNode);
          this.saveStateAndRender();
        };
        document.getElementById('addRootTxt').onclick = () => {
            const newNode = this.createNode('新しいファイル.txt', 'file');
            this.root.children.push(newNode);
            this.saveStateAndRender();
        };
        document.getElementById('saveCsv').onclick = () => {
          const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
          const csv = treeToCsv(this.root);
          const blob = new Blob([bom, csv], { type: 'text/csv' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'structure.csv';
          a.click();
        };
        document.getElementById('loadCsv').onclick = async () => {
          const newRoot = await loadCsv(this.createNode.bind(this));
          if (newRoot) {
            this.root = newRoot;
            this.idCounter = getMaxId(this.root) + 1;
            this.saveStateAndRender();
          }
        };
        document.getElementById('importFs').onclick = async () => {
          try {
            const dh = await window.showDirectoryPicker();
            this.idCounter = 1;
            this.root = this.createNode('/', 'folder');
            await readFsRecursive(dh, this.root, this.createNode.bind(this));
            this.saveStateAndRender();
          } catch (e) {
            if (e.name !== 'AbortError') alert('フォルダの読み込みに失敗しました。');
          }
        };
        document.getElementById('downloadZip').onclick = () => downloadZip(this.root);
        document.getElementById('downloadPng').onclick = () => {
          const originalBodyPadding = document.body.style.padding;
          document.body.style.padding = '0';
          document.body.classList.add('hide-for-capture');
          html2canvas(document.getElementById('tree'), {
            scale: 2,
            logging: false,
            useCORS: true,
            backgroundColor: '#f8f9fa',
          }).then(canvas => {
            const a = document.createElement('a');
            a.href = canvas.toDataURL('image/png');
            a.download = 'structure.png';
            a.click();
          }).finally(() => {
            document.body.classList.remove('hide-for-capture');
            document.body.style.padding = originalBodyPadding;
          });
        };
        document.getElementById('txtPreviewBtn').onclick = () => {
          let txt = '';
          const walk = (n, prefix = '') => {
            n.children.forEach(c => {
              txt += prefix + c.name + (c.type === 'folder' ? '/' : '') + '\n';
              if (c.type === 'file' && c.content) {
                txt += c.content.split(/\r?\n/).map(line => '　' + line).join('\n') + '\n\n';
              }
              if (c.type === 'folder') walk(c, prefix + '　');
            });
          };
          walk(this.root);
          document.getElementById('txt-preview').textContent = txt;
          document.getElementById('txt-preview').style.display = 'block';
        };
        document.getElementById('undoBtn').onclick = () => {
          const newState = this.historyManager.undo();
          if (newState) {
            this.root = newState;
            this.idCounter = getMaxId(this.root) + 1;
            this.selectedId = null;
            this.render();
          }
        };
        document.getElementById('redoBtn').onclick = () => {
          const newState = this.historyManager.redo();
          if (newState) {
            this.root = newState;
            this.idCounter = getMaxId(this.root) + 1;
            this.selectedId = null;
            this.render();
          }
        };
        document.getElementById('saveAllBtn').onclick = () => {
          const blob = new Blob([JSON.stringify(this.root, null, 2)], { type: 'application/json' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'structure.json';
          a.click();
        };
        document.getElementById('loadAllBtn').onclick = async () => {
          try {
            const [f] = await window.showOpenFilePicker({ types: [{ accept: { 'application/json': ['.json'] } }] });
            const txt = await (await f.getFile()).text();
            this.root = JSON.parse(txt);
            this.idCounter = getMaxId(this.root) + 1;
            this.saveStateAndRender();
          } catch (e) {
            if (e.name !== 'AbortError') alert('JSONファイルの読み込みに失敗しました。');
          }
        };
        document.getElementById('addFavBtn').onclick = () => {
          const name = prompt('お気に入り名を入力してください:');
          if (!name) return;
          const favs = JSON.parse(localStorage.getItem('favTemplates') || '[]');
          favs.push({ name, data: JSON.stringify(this.root) });
          localStorage.setItem('favTemplates', JSON.stringify(favs));
          this.renderFavList();
        };
        document.getElementById('clearAllBtn').onclick = () => {
          if (confirm('本当にすべて削除しますか？')) {
            this.root = this.createNode('/', 'folder');
            this.idCounter = 1;
            this.saveStateAndRender();
          }
        };
        document.querySelectorAll('#color-picker input[name="color"]').forEach(radio => {
          radio.addEventListener('change', (e) => {
            if (this.selectedId) {
              const node = findNode(this.root, this.selectedId);
              if (node) {
                node.color = e.target.value;
                if (node.type === 'folder') {
                  this.updateChildrenColor(node, e.target.value);
                }
                this.saveStateAndRender();
              }
            }
          });
        });
        document.getElementById('modal-cancel').onclick = () => {
          document.getElementById('modal-bg').style.display = 'none';
          this.modalNode = null;
        };
        document.getElementById('modal-ok').onclick = () => {
          if (this.modalNode) {
            this.modalNode.content = document.getElementById('modal-text').value;
            this.saveStateAndRender();
          }
          document.getElementById('modal-bg').style.display = 'none';
          this.modalNode = null;
        };
      }
    }
    new App();
  </script>
</body>
</html>
