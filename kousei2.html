<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>超高機能構造エディタ + 実行 & 履歴付き</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<style>
  *, *::before, *::after {box-sizing: border-box;}
  html, body {
    height: 100%; margin: 0; padding: 0;
    font-family: -apple-system, BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,
      Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif;
    background: #f9fafb;
    overflow: hidden;
    user-select: none;
  }
  h2 {
    margin:0; padding:1rem;
    background-color: #4338ca;
    color: white;
    font-weight: 700;
    font-size: 1.2rem;
    text-align: center;
    user-select: text;
  }
  #app {
    display: flex; flex-direction: column; height: 100vh; overflow: hidden;
  }
  #bar {
    display: flex; flex-wrap: wrap; align-items: center;
    gap: 8px;
    padding: 0.5rem 1rem;
    background-color: #eef2ff;
    user-select: none;
    flex-shrink: 0;
  }
  #left-controls {
    display: flex; gap: 6px; flex-wrap: wrap; max-width: 60%;
  }
  #search {
    flex-grow: 1;
    max-width: 40vw;
    min-width: 120px;
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid #a5b4fc;
    outline: none;
    font-size: 1rem;
    box-shadow: inset 0 0 8px #dbeafe;
  }
  #search:focus {
    border-color: #4338ca;
    box-shadow: 0 0 9px #818cf8;
  }
  button, select, input[type=color] {
    cursor: pointer;
    border-radius: 8px;
    border: 1px solid #a5b4fc;
    background: white;
    min-width: 32px;
    font-size: 1rem;
    padding: 6px 10px;
    font-weight: 700;
    transition: background-color 0.15s, border-color 0.15s;
    user-select: none;
    white-space: nowrap;
  }
  button:disabled, button[disabled] {
    opacity: 0.4;
    cursor: default;
  }
  button:hover:not(:disabled), select:hover, input[type=color]:hover {
    background: #eef2ff;
    border-color: #4338ca;
  }
  select {
    font-weight: 600;
    min-width: 120px;
  }
  #color-picker {
    display: flex;
    align-items: center;
    gap: 8px;
    user-select: none;
    min-width: 75px;
  }
  #color-picker label {
    font-weight: 700;
    font-size: 1rem;
    margin-right: 4px;
  }
  #color-input {
    width: 34px;
    height: 34px;
    padding: 0;
    border: none;
    cursor: pointer;
    border-radius: 8px;
    box-shadow: 0 0 4px #a5b4fc;
    transition: box-shadow 0.2s ease;
  }
  #color-input:focus {
    outline: none;
    box-shadow: 0 0 6px #4338ca;
  }
  #tree-container {
    flex-grow: 1;
    overflow-y: auto;
    background: white;
    border-top: 2px solid #4338ca;
    border-bottom: 2px solid #4338ca;
    padding: 0.7rem 0.8rem 0.8rem 1rem;
    -webkit-overflow-scrolling: touch;
    user-select: text;
  }
  #tree {
    list-style: none;
    padding-left: 0;
    margin: 0;
    font-family: monospace;
    font-size: 1rem;
  }
  li {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 5px 8px;
    border-radius: 8px;
    cursor: pointer;
    white-space: nowrap;
    position: relative;
    user-select: text;
    -webkit-user-select: text;
  }
  li.dragging {
    opacity: 0.5;
  }
  li.over-drop-before {
    border-top: 3px solid #4338ca !important;
  }
  li.over-drop-after {
    border-bottom: 3px solid #4338ca !important;
  }
  li.over-drop-inside > .node-inner {
    background-color: #dbeafe !important;
    border-radius: 8px;
  }
  .children {
    border-left: 2px solid #a5b4fc;
    margin-left: 2rem;
    padding-left: 0.6rem;
    user-select: none;
  }
  .toggle-btn {
    background: none;
    border: none;
    cursor: pointer;
    font-weight: 700;
    font-size: 1.1rem;
    padding: 0;
    width: 1.35rem;
    color: #4338ca;
    user-select: none;
    line-height: 1;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .toggle-btn:focus-visible {
    outline: 3px solid #4338ca;
    outline-offset: 2px;
  }
  .node-inner {
    flex-grow: 1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 12px;
    border-radius: 8px;
    border: 1px solid transparent;
    user-select: text;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    min-width: 0;
  }
  .node-inner.selected {
    background-color: #4338ca;
    color: white;
    border-color: #4338ca;
  }
  .node-inner:focus-visible {
    outline: 3px solid #4338ca;
    outline-offset: 3px;
  }
  .node-type-icon {
    font-size: 1.3rem;
    margin-right: 6px;
    flex-shrink: 0;
    user-select: none;
    width: 1.4rem;
    text-align: center;
    line-height: 1;
  }
  .node-name {
    flex-grow: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    user-select: text;
    -webkit-user-select: text;
  }
  .actions {
    display: flex;
    gap: 6px;
    flex-shrink: 0;
    user-select: none;
  }
  .actions button {
    background: transparent;
    border: none;
    border-radius: 6px;
    transition: background-color 0.15s ease-in-out;
    font-size: 1.1rem;
    padding: 3px 8px;
    color: #4338ca;
    cursor: pointer;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  .actions button:disabled {
    color: #a5b4fc;
    cursor: default;
  }
  .actions button:hover:not(:disabled) {
    background-color: #c7d2fe;
  }
  .tooltip {
    position: relative;
    display: inline-block;
  }
  .tooltip .tooltiptext {
    visibility: hidden;
    width: 80px;
    background-color: #4338ca;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 5px 0;
    position: absolute;
    z-index: 10;
    bottom: 130%;
    left: 50%;
    margin-left: -40px;
    opacity: 0;
    transition: opacity 0.3s ease;
    user-select: none;
    font-size: 0.85rem;
    line-height: 1.2;
  }
  .tooltip:hover .tooltiptext,
  .tooltip:focus-within .tooltiptext {
    visibility: visible;
    opacity: 1;
  }
  #modal-bg {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0,0,0,0.4);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 20000;
    -webkit-overflow-scrolling: touch;
  }
  #modal {
    background: white;
    border-radius: 10px;
    box-shadow: 0 6px 30px rgba(0,0,0,0.25);
    padding: 1.5rem;
    width: min(90vw, 600px);
    max-height: 80vh;
    display: flex;
    flex-direction: column;
  }
  #modal label {
    font-weight: 700;
    font-size: 1.1rem;
    margin-bottom: 1rem;
    user-select: none;
  }
  #modal-text {
    flex-grow: 1;
    width: 100%;
    resize: vertical;
    min-height: 200px;
    font-family: monospace;
    font-size: 1rem;
    padding: 10px 14px;
    border-radius: 10px;
    border: 1px solid #bbb;
    outline: none;
    box-sizing: border-box;
    font-weight: 400;
    line-height: 1.4;
    user-select: text;
    -webkit-user-select: text;
  }
  #modal-text:focus {
    border-color: #4338ca;
    box-shadow: 0 0 8px #818cf8;
  }
  #modal-btns {
    display: flex;
    justify-content: flex-end;
    gap: 14px;
    margin-top: 1rem;
  }
  #modal-btns button {
    cursor: pointer;
    border-radius: 10px;
    padding: 8px 22px;
    font-weight: 600;
    font-size: 1rem;
    border: none;
    min-width: 90px;
    user-select: none;
    transition: background-color 0.2s ease;
  }
  #modal-btns .cancel-btn {
    background-color: #e0e0e0;
    color: #333;
  }
  #modal-btns .cancel-btn:hover {
    background-color: #c0c0c0;
  }
  #modal-btns .save-btn {
    background-color: #4338ca;
    color: white;
    box-shadow: 0 0 12px #4338cacc;
  }
  #modal-btns .save-btn:hover {
    background-color: #2c23a9;
    box-shadow: 0 0 14px #2c23a9dd;
  }
  @media (max-width: 600px) {
    #bar {
      flex-direction: column;
      align-items: stretch;
    }
    #left-controls, #search, #color-picker {
      max-width: 100% !important;
      flex-grow: 1 !important;
    }
    .actions button {
      font-size: 1.25rem;
      padding: 5px 10px;
    }
    li {
      padding: 6px 12px;
    }
    #tree {
      font-size: 1.125rem;
    }
    .node-inner {
      padding: 10px 16px;
    }
  }
</style>
</head>
<body>
  <div id="app" role="application" aria-label="構造エディタ">
    <h2>🚀 超高機能構造エディタ (縦画面スマホ対応・履歴付き)</h2>
    <div id="bar" role="region" aria-label="ツールバー">
      <div id="left-controls">
        <select aria-label="プリセットテンプレート選択" id="template-select" title="プリセットテンプレート">
          <option value="">白紙から開始</option>
          <option value="js">JavaScriptプロジェクト</option>
          <option value="web">Webサイト構成</option>
          <option value="docs">ドキュメント構成</option>
        </select>
        <button id="btn-add-folder" type="button" title="ルートに新規フォルダを追加">📁 フォルダ追加</button>
        <button id="btn-add-file" type="button" title="ルートに新規ファイルを追加">📄 ファイル追加</button>
        <button id="btn-add-html" type="button" title="ルートに新規HTMLファイルを追加">📄 HTML追加</button>
        <button id="btn-save-json" type="button" title="現在の構造をJSONで保存">💾 保存</button>
        <button id="btn-load-json" type="button" title="JSONファイルを読み込む">📂 読込</button>
        <button id="btn-export-zip" type="button" title="構造をZIPファイルで出力">🗜 ZIP出力</button>
        <button id="btn-download-png" type="button" title="構造をPNG画像で出力">🖼 PNG出力</button>
        <button id="btn-undo" type="button" title="戻る（Undo）">↩ 戻る</button>
        <button id="btn-redo" type="button" title="進む（Redo）">↪ 進む</button>
      </div>
      <input id="search" type="search" autocomplete="off" placeholder="🔍 検索... (名前・内容対象)" aria-label="検索ボックス" />
      <div id="color-picker" title="選択中ノードの色を変更">
        <label for="color-input">🎨 色:</label>
        <input type="color" id="color-input" value="#ffffff" aria-label="ノード色選択"/>
      </div>
    </div>
    <div id="tree-container" tabindex="0" aria-label="ファイルツリー">
      <ul id="tree" role="tree" aria-live="polite" aria-relevant="additions removals"></ul>
    </div>
  </div>

  <div id="modal-bg" role="dialog" aria-modal="true" aria-labelledby="modal-label" tabindex="-1">
    <div id="modal">
      <label id="modal-label" for="modal-text">内容編集</label>
      <textarea id="modal-text" aria-multiline="true" spellcheck="false"></textarea>
      <div id="modal-btns">
        <button class="cancel-btn" id="modal-cancel" type="button">キャンセル</button>
        <button class="save-btn" id="modal-ok" type="button">保存</button>
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<script>
(() => {
  // ===== 状態管理 =====
  const templates = {
    js: `/my-app
├── README.md
├── package.json
├── src/
│   └── index.js
└── tests/
    └── test.js`.trim(),
    web: `/site
├── index.html
├── assets/
│   ├── style.css
│   └── script.js`.trim(),
    docs: `/docs
├── README.md
├── guide.md
└── changelog.md`.trim()
  };

  let idCounter = 1;
  const genId = () => 'n' + (idCounter++);
  function createNode(name, type, color = '#ffffff', expanded = true) {
    return {
      id: genId(),
      name,
      type,
      color,
      expanded,
      children: type === 'folder' ? [] : null,
      content: type === 'file' ? '' : null
    };
  }

  let root = createNode('/', 'folder');
  let selectedId = null;
  let editingId = null;
  let draggedId = null;
  let dropPosition = null;
  let clipboard = null;
  let modalNode = null;

  // Undo/Redo履歴管理
  const history = [];
  const future = [];
  function saveHistory() {
    history.push(JSON.stringify(root));
    if(history.length > 100) history.shift();
    future.length = 0;
    updateUndoRedoButtons();
  }
  function undo() {
    if (history.length <= 1) return;
    future.push(history.pop());
    root = JSON.parse(history[history.length - 1]);
    selectedId = null;
    editingId = null;
    render();
    updateUndoRedoButtons();
  }
  function redo() {
    if (future.length === 0) return;
    const next = future.pop();
    history.push(next);
    root = JSON.parse(next);
    selectedId = null;
    editingId = null;
    render();
    updateUndoRedoButtons();
  }
  function updateUndoRedoButtons() {
    document.getElementById('btn-undo').disabled = history.length <= 1;
    document.getElementById('btn-redo').disabled = future.length === 0;
  }

  // ===== DOM Elements =====
  const treeEl = document.getElementById('tree');
  const templateSelect = document.getElementById('template-select');
  const btnAddFolder = document.getElementById('btn-add-folder');
  const btnAddFile = document.getElementById('btn-add-file');
  const btnAddHtml = document.getElementById('btn-add-html');
  const btnSaveJson = document.getElementById('btn-save-json');
  const btnLoadJson = document.getElementById('btn-load-json');
  const btnExportZip = document.getElementById('btn-export-zip');
  const btnDownloadPng = document.getElementById('btn-download-png');
  const btnUndo = document.getElementById('btn-undo');
  const btnRedo = document.getElementById('btn-redo');
  const searchInput = document.getElementById('search');
  const colorInput = document.getElementById('color-input');
  const modalBg = document.getElementById('modal-bg');
  const modalText = document.getElementById('modal-text');
  const modalCancel = document.getElementById('modal-cancel');
  const modalOk = document.getElementById('modal-ok');

  // ===== ユーティリティ =====
  function findNodeById(node, id) {
    if (node.id === id) return node;
    if (node.type === 'folder') {
      for (const c of node.children) {
        const found = findNodeById(c, id);
        if (found) return found;
      }
    }
    return null;
  }
  function findParentById(node, childId) {
    if (node.type !== 'folder') return null;
    for (const c of node.children) {
      if (c.id === childId) return node;
      const found = findParentById(c, childId);
      if (found) return found;
    }
    return null;
  }
  function cloneNode(node) {
    const copy = JSON.parse(JSON.stringify(node));
    (function renewIds(n) {
      n.id = genId();
      if(n.type === 'folder' && n.children) n.children.forEach(renewIds);
    })(copy);
    return copy;
  }
  function nodeMatchesSearch(node, term) {
    if (!term || term.length < 1) return true;
    term = term.toLowerCase();
    if (node.name.toLowerCase().includes(term)) return true;
    if (node.type === 'file' && node.content && node.content.toLowerCase().includes(term)) return true;
    if (node.type === 'folder') return node.children.some(c => nodeMatchesSearch(c, term));
    return false;
  }
  function getFileTemplate(name) {
    if (name.match(/\.html?$/i)) return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>${name.replace(/\.html?$/i, '')}</title>
</head>
<body>
    <h1>Hello, World!</h1>
</body>
</html>`;
    if (name.match(/\.js$/i)) return `// ${name}\nconsole.log('Hello, world!');`;
    if (name.match(/\.css$/i)) return `/* ${name} */\nbody {\n  margin: 0;\n}\n`;
    return '';
  }
  function getContrastYIQ(hexcolor) {
    if (!hexcolor) return '#000000';
    hexcolor = hexcolor.replace("#", "");
    const r = parseInt(hexcolor.substr(0,2),16);
    const g = parseInt(hexcolor.substr(2,2),16);
    const b = parseInt(hexcolor.substr(4,2),16);
    const yiq = (r*299 + g*587 + b*114) / 1000;
    return yiq >= 128 ? '#000000' : '#FFFFFF';
  }
  function isDescendant(parentNode, possibleDescendant) {
    if (parentNode.type !== 'folder') return false;
    for (const c of parentNode.children) {
      if (c.id === possibleDescendant.id) return true;
      if (c.type === 'folder' && isDescendant(c, possibleDescendant)) return true;
    }
    return false;
  }
  function clearDragClasses() {
    document.querySelectorAll('#tree li').forEach(el => {
      el.classList.remove('over-drop-before', 'over-drop-after', 'over-drop-inside');
    });
  }

  // ===== レンダリング =====
  function render() {
    treeEl.innerHTML = '';
    function build(node, container) {
      node.children.forEach(child => {
        if (!nodeMatchesSearch(child, searchInput.value.trim())) return;

        const li = document.createElement('li');
        li.setAttribute('role', 'treeitem');
        li.dataset.id = child.id;
        li.tabIndex = 0;
        li.setAttribute('aria-expanded', child.type === 'folder' ? String(child.expanded) : undefined);
        li.classList.remove('dragging', 'over-drop-before', 'over-drop-after', 'over-drop-inside');

        // 折りたたみボタン
        if (child.type === 'folder') {
          const toggleBtn = document.createElement('button');
          toggleBtn.className = 'toggle-btn';
          toggleBtn.ariaLabel = child.expanded ? '折り畳む' : '展開する';
          toggleBtn.textContent = child.expanded ? '▼' : '▶';
          toggleBtn.addEventListener('click', e => {
            child.expanded = !child.expanded;
            render();
            e.stopPropagation();
          });
          li.appendChild(toggleBtn);
        } else {
          const spacer = document.createElement('span');
          spacer.style.width = '1.35rem';
          li.appendChild(spacer);
        }

        // インライン編集または通常表示
        if (editingId === child.id) {
          const input = document.createElement('input');
          input.type = 'text';
          input.value = child.name;
          input.className = 'node-inner';
          input.style.flexGrow = '1';
          li.appendChild(input);
          input.focus();
          input.select();
          input.addEventListener('blur', e => {
            const val = e.target.value.trim();
            if(val.length > 0) child.name = val;
            if(child.type === 'file' && (!child.content || child.content.trim() === ''))
              child.content = getFileTemplate(val);
            editingId = null;
            saveHistory();
            render();
          });
          input.addEventListener('keydown', e => {
            if(e.key === 'Enter') input.blur();
            if(e.key === 'Escape') {
              editingId = null;
              render();
            }
          });
        } else {
          const nodeInner = document.createElement('div');
          nodeInner.className = 'node-inner' + (child.id === selectedId ? ' selected' : '');
          nodeInner.tabIndex = 0;

          // アイコン
          const icon = document.createElement('span');
          icon.className = 'node-type-icon tooltip';
          icon.textContent = child.type === 'folder' ? '📁' : '📄';
          const tooltip = document.createElement('span');
          tooltip.className = 'tooltiptext';
          tooltip.textContent = child.type === 'folder' ? 'フォルダ' : 'ファイル';
          icon.appendChild(tooltip);
          nodeInner.appendChild(icon);

          const nameSpan = document.createElement('span');
          nameSpan.className = 'node-name';
          nameSpan.textContent = child.name + (child.type === 'folder' ? '/' : '');
          nodeInner.appendChild(nameSpan);

          if (child.color && child.color !== '#ffffff') {
            nodeInner.style.backgroundColor = child.color;
            nodeInner.style.color = getContrastYIQ(child.color);
          } else {
            nodeInner.style.backgroundColor = '';
            nodeInner.style.color = '';
          }

          // 選択・ダブルクリック
          nodeInner.addEventListener('click', e => {
            e.stopPropagation();
            selectedId = child.id;
            editingId = null;
            updateColorPicker();
            render();
          });
          nodeInner.addEventListener('dblclick', e => {
            e.stopPropagation();
            if(child.type === 'file') openModal(child);
            else {
              child.expanded = !child.expanded;
              render();
            }
          });

          li.appendChild(nodeInner);
        }

        // アクションボタン群
        const actions = document.createElement('span');
        actions.className = 'actions';

        // HTML実行ボタン
        if (child.type === 'file' && (child.name.endsWith('.html') || child.name.endsWith('.htm'))) {
          const btnRun = document.createElement('button');
          btnRun.textContent = '▶';
          btnRun.title = '実行';
          btnRun.addEventListener('click', e => {
            e.stopPropagation();
            const win = window.open('', '_blank');
            win.document.open();
            win.document.write(child.content);
            win.document.close();
          });
          actions.appendChild(btnRun);
        }

        // 名前変更(F2)
        const btnRename = document.createElement('button');
        btnRename.textContent = '✎';
        btnRename.title = '名前変更 (F2)';
        btnRename.addEventListener('click', e => {
          e.stopPropagation();
          editingId = child.id;
          selectedId = null;
          render();
        });
        actions.appendChild(btnRename);

        // 内容編集(Enter)
        if (child.type === 'file') {
          const btnEdit = document.createElement('button');
          btnEdit.textContent = '📝';
          btnEdit.title = '内容編集 (Enter)';
          btnEdit.addEventListener('click', e => {
            e.stopPropagation();
            openModal(child);
          });
          actions.appendChild(btnEdit);
        }

        // コピー(Ctrl+C)
        const btnCopy = document.createElement('button');
        btnCopy.textContent = '📋';
        btnCopy.title = 'コピー (Ctrl+C)';
        btnCopy.addEventListener('click', e => {
          e.stopPropagation();
          clipboard = cloneNode(child);
        });
        actions.appendChild(btnCopy);

        // ペースト(Ctrl+V)
        if (child.type === 'folder' && clipboard) {
          const btnPaste = document.createElement('button');
          btnPaste.textContent = '📌';
          btnPaste.title = 'ペースト (Ctrl+V)';
          btnPaste.addEventListener('click', e => {
            e.stopPropagation();
            const pastedNode = cloneNode(clipboard);
            child.children.push(pastedNode);
            child.expanded = true;
            saveHistory();
            render();
          });
          actions.appendChild(btnPaste);
        }

        // 削除(Del)
        const btnDelete = document.createElement('button');
        btnDelete.textContent = '✖';
        btnDelete.title = '削除 (Del)';
        btnDelete.addEventListener('click', e => {
          e.stopPropagation();
          if (confirm(`${child.name} を削除しますか？`)) {
            const parent = findParentById(root, child.id);
            if (parent) {
              parent.children = parent.children.filter(c => c.id !== child.id);
              saveHistory();
              render();
            }
          }
        });
        actions.appendChild(btnDelete);

        li.appendChild(actions);

        container.appendChild(li);

        if (child.type === 'folder' && child.expanded) {
          const ul = document.createElement('ul');
          ul.className = 'children';
          build(child, ul);
          li.appendChild(ul);
        }
      });
    }

    build(root, treeEl);
    updateUndoRedoButtons();
  }

  // ===== イベントハンドラ =====
  btnAddFolder.addEventListener('click', () => {
    root.children.push(createNode('新規フォルダ', 'folder'));
    root.expanded = true;
    saveHistory();
    render();
  });
  btnAddFile.addEventListener('click', () => {
    root.children.push(createNode('新規ファイル.txt', 'file'));
    root.expanded = true;
    saveHistory();
    render();
  });
  btnAddHtml.addEventListener('click', () => {
    const newNode = createNode('index.html', 'file');
    newNode.content = getFileTemplate('index.html');
    root.children.push(newNode);
    root.expanded = true;
    saveHistory();
    render();
  });
  btnSaveJson.addEventListener('click', () => {
    const json = JSON.stringify(root, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'structure.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });
  btnLoadJson.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json';
    input.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const loadedRoot = JSON.parse(e.target.result);
          if (loadedRoot && loadedRoot.type === 'folder' && Array.isArray(loadedRoot.children)) {
            root = loadedRoot;
            saveHistory();
            render();
            alert('JSONを読み込みました！');
          } else {
            alert('有効な構造データではありません。');
          }
        } catch (error) {
          alert('JSONファイルの解析に失敗しました。');
        }
      };
      reader.readAsText(file);
    };
    input.click();
  });
  btnExportZip.addEventListener('click', async () => {
    const zip = new JSZip();
    function createZipStructure(node, currentZip) {
      if (node.type === 'folder') {
        const folder = currentZip.folder(node.name);
        node.children.forEach(child => createZipStructure(child, folder));
      } else if (node.type === 'file') {
        currentZip.file(node.name, node.content || '');
      }
    }
    root.children.forEach(child => createZipStructure(child, zip));
    zip.generateAsync({ type: "blob" }).then(content => {
      const url = URL.createObjectURL(content);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'project.zip';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  });
  btnDownloadPng.addEventListener('click', async () => {
    const container = document.getElementById('tree-container');
    const originalStyle = container.style.boxShadow;
    container.style.boxShadow = 'none';

    // 一時的に余白を調整して見栄えを良くする
    const tempPadding = container.style.padding;
    container.style.padding = '20px';

    html2canvas(container, {
      backgroundColor: '#ffffff',
      scale: 2,
      useCORS: true
    }).then(canvas => {
      container.style.boxShadow = originalStyle;
      container.style.padding = tempPadding;

      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'structure.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });
  });
  btnUndo.addEventListener('click', undo);
  btnRedo.addEventListener('click', redo);
  searchInput.addEventListener('input', render);
  colorInput.addEventListener('change', () => {
    const node = findNodeById(root, selectedId);
    if (node) {
      node.color = colorInput.value;
      saveHistory();
      render();
    }
  });
  function updateColorPicker() {
    const node = findNodeById(root, selectedId);
    if (node) {
      colorInput.value = node.color || '#ffffff';
      colorInput.disabled = false;
    } else {
      colorInput.value = '#ffffff';
      colorInput.disabled = true;
    }
  }

  // モーダル関連
  function openModal(node) {
    modalNode = node;
    modalText.value = node.content;
    modalBg.style.display = 'flex';
    modalText.focus();
  }
  modalCancel.addEventListener('click', () => {
    modalBg.style.display = 'none';
    modalNode = null;
  });
  modalOk.addEventListener('click', () => {
    if (modalNode) {
      modalNode.content = modalText.value;
      saveHistory();
    }
    modalBg.style.display = 'none';
    modalNode = null;
    render();
  });
  modalBg.addEventListener('click', e => {
    if (e.target.id === 'modal-bg') {
      modalBg.style.display = 'none';
      modalNode = null;
    }
  });

  // キーボードショートカット
  document.addEventListener('keydown', e => {
    if (editingId) return;

    if (modalBg.style.display === 'flex') {
      if (e.key === 'Escape') {
        modalCancel.click();
      }
      return;
    }

    const selectedNode = findNodeById(root, selectedId);
    if (selectedNode) {
      if (e.key === 'F2') {
        e.preventDefault();
        editingId = selectedId;
        render();
      } else if (e.key === 'Delete' || e.key === 'Backspace') {
        e.preventDefault();
        const parent = findParentById(root, selectedNode.id);
        if (parent && confirm(`${selectedNode.name} を削除しますか？`)) {
          parent.children = parent.children.filter(c => c.id !== selectedNode.id);
          selectedId = null;
          saveHistory();
          render();
        }
      } else if (e.key === 'Enter' && selectedNode.type === 'file') {
        e.preventDefault();
        openModal(selectedNode);
      } else if (e.ctrlKey && e.key === 'c') {
        e.preventDefault();
        clipboard = cloneNode(selectedNode);
      } else if (e.ctrlKey && e.key === 'v') {
        e.preventDefault();
        const parent = selectedNode.type === 'folder' ? selectedNode : findParentById(root, selectedId);
        if (clipboard && parent) {
          const pastedNode = cloneNode(clipboard);
          parent.children.push(pastedNode);
          parent.expanded = true;
          saveHistory();
          render();
        }
      }
    }

    if (e.ctrlKey && e.key === 'z') {
      e.preventDefault();
      undo();
    }
    if (e.ctrlKey && e.key === 'y') {
      e.preventDefault();
      redo();
    }
  });

  // ドラッグ＆ドロップ機能
  let draggedEl = null;
  treeEl.addEventListener('dragstart', e => {
    if (e.target.tagName === 'LI') {
      draggedEl = e.target;
      draggedId = draggedEl.dataset.id;
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', draggedId);
      setTimeout(() => draggedEl.classList.add('dragging'), 0);
    }
  });
  treeEl.addEventListener('dragend', () => {
    clearDragClasses();
    if (draggedEl) {
      draggedEl.classList.remove('dragging');
      draggedEl = null;
    }
    draggedId = null;
    dropPosition = null;
  });
  treeEl.addEventListener('dragover', e => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    clearDragClasses();

    const targetEl = e.target.closest('li');
    if (!targetEl || targetEl === draggedEl) return;

    const rect = targetEl.getBoundingClientRect();
    const y = e.clientY;
    const hoverMiddleY = rect.top + rect.height / 2;
    const targetNode = findNodeById(root, targetEl.dataset.id);
    const draggedNode = findNodeById(root, draggedId);

    if (targetNode === draggedNode || isDescendant(draggedNode, targetNode)) {
      dropPosition = null;
      return;
    }

    if (y < hoverMiddleY - 5) {
      targetEl.classList.add('over-drop-before');
      dropPosition = 'before';
    } else if (y > hoverMiddleY + 5) {
      targetEl.classList.add('over-drop-after');
      dropPosition = 'after';
    } else {
      if (targetNode.type === 'folder') {
        targetEl.classList.add('over-drop-inside');
        dropPosition = 'inside';
      } else {
        targetEl.classList.add('over-drop-after');
        dropPosition = 'after';
      }
    }
  });
  treeEl.addEventListener('drop', e => {
    e.preventDefault();
    clearDragClasses();
    if (!draggedId || !dropPosition) return;

    const sourceNode = findNodeById(root, draggedId);
    const sourceParent = findParentById(root, draggedId);
    const targetEl = e.target.closest('li');
    if (!sourceNode || !sourceParent || !targetEl) return;

    const targetNode = findNodeById(root, targetEl.dataset.id);
    if (!targetNode || targetNode === sourceNode || isDescendant(sourceNode, targetNode)) return;

    sourceParent.children = sourceParent.children.filter(c => c.id !== sourceNode.id);

    if (dropPosition === 'inside' && targetNode.type === 'folder') {
      targetNode.children.push(sourceNode);
      targetNode.expanded = true;
    } else {
      const targetParent = findParentById(root, targetNode.id);
      if (!targetParent) return;
      const targetIndex = targetParent.children.findIndex(c => c.id === targetNode.id);
      if (dropPosition === 'before') {
        targetParent.children.splice(targetIndex, 0, sourceNode);
      } else if (dropPosition === 'after') {
        targetParent.children.splice(targetIndex + 1, 0, sourceNode);
      }
    }

    saveHistory();
    render();
  });

  // 初期化
  saveHistory();
  render();
})();
</script>
</body>
</html>
