<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>超安定・快適・高機能ファイル構造エディタ</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    /* Reset & base */
    *, *::before, *::after {
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      margin: 0; padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
        Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background: #f9fafb;
      overflow: hidden;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    h2 {
      margin:0; padding: 1rem;
      background-color: #4338ca;
      color: white;
      font-weight: 700;
      font-size: 1.2rem;
      text-align: center;
      user-select: text;
      flex-shrink: 0;
    }
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    #bar {
      display: flex; flex-wrap: wrap; align-items: center;
      gap: 8px;
      padding: 0.5rem 1rem;
      background-color: #eef2ff;
      user-select: none;
      flex-shrink: 0;
    }
    #left-controls {
      display: flex; gap: 6px; flex-wrap: wrap; max-width: 60%;
    }
    #search {
      flex-grow: 1;
      max-width: 40vw;
      min-width: 120px;
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #a5b4fc;
      outline: none;
      font-size: 1rem;
      box-shadow: inset 0 0 8px #dbeafe;
    }
    #search:focus {
      border-color: #4338ca;
      box-shadow: 0 0 9px #818cf8;
    }
    button, select, input[type=color] {
      cursor: pointer;
      border-radius: 8px;
      border: 1px solid #a5b4fc;
      background: white;
      min-width: 32px;
      font-size: 1rem;
      padding: 6px 10px;
      font-weight: 700;
      transition: background-color 0.15s, border-color 0.15s;
      user-select: none;
      white-space: nowrap;
    }
    button:disabled, button[disabled] {
      opacity: 0.4;
      cursor: default;
    }
    button:hover:not(:disabled), select:hover, input[type=color]:hover {
      background: #eef2ff;
      border-color: #4338ca;
    }
    select {
      font-weight: 600;
      min-width: 120px;
    }
    #color-picker {
      display: flex;
      align-items: center;
      gap: 8px;
      user-select: none;
      min-width: 75px;
    }
    #color-picker label {
      font-weight: 700;
      font-size: 1rem;
      margin-right: 4px;
      user-select: text;
    }
    #color-input {
      width: 34px;
      height: 34px;
      padding: 0;
      border: none;
      cursor: pointer;
      border-radius: 8px;
      box-shadow: 0 0 4px #a5b4fc;
      transition: box-shadow 0.2s ease;
    }
    #color-input:focus {
      outline: none;
      box-shadow: 0 0 6px #4338ca;
    }
    #tree-container {
      flex-grow: 1;
      overflow-y: auto;
      background: white;
      border-top: 2px solid #4338ca;
      border-bottom: 2px solid #4338ca;
      padding: 0.7rem 0.8rem 0.8rem 1rem;
      -webkit-overflow-scrolling: touch;
      user-select: text;
    }
    #tree {
      list-style: none;
      padding-left: 0;
      margin: 0;
      font-family: monospace;
      font-size: 1rem;
    }
    li {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 5px 8px;
      border-radius: 8px;
      cursor: pointer;
      white-space: nowrap;
      position: relative;
      user-select: text;
      -webkit-user-select: text;
    }
    li.dragging {
      opacity: 0.5;
    }
    li.over-drop-before {
      border-top: 3px solid #4338ca !important;
    }
    li.over-drop-after {
      border-bottom: 3px solid #4338ca !important;
    }
    li.over-drop-inside > .node-inner {
      background-color: #dbeafe !important;
      border-radius: 8px;
    }
    .children {
      border-left: 2px solid #a5b4fc;
      margin-left: 2rem;
      padding-left: 0.6rem;
      user-select: none;
    }
    .toggle-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-weight: 700;
      font-size: 1.1rem;
      padding: 0;
      width: 1.35rem;
      color: #4338ca;
      user-select: none;
      line-height: 1;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .toggle-btn:focus-visible {
      outline: 3px solid #4338ca;
      outline-offset: 2px;
    }
    .node-inner {
      flex-grow: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid transparent;
      user-select: text;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      min-width: 0;
    }
    .node-inner.selected {
      background-color: #4338ca;
      color: white;
      border-color: #4338ca;
    }
    .node-inner:focus-visible {
      outline: 3px solid #4338ca;
      outline-offset: 3px;
    }
    .node-type-icon {
      font-size: 1.3rem;
      margin-right: 6px;
      flex-shrink: 0;
      user-select: none;
      width: 1.4rem;
      text-align: center;
      line-height: 1;
    }
    .node-name {
      flex-grow: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      user-select: text;
      -webkit-user-select: text;
    }
    .actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
      user-select: none;
    }
    .actions button {
      background: transparent;
      border: none;
      border-radius: 6px;
      transition: background-color 0.15s ease-in-out;
      font-size: 1.1rem;
      padding: 3px 8px;
      color: #4338ca;
      cursor: pointer;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
    }
    .actions button:disabled {
      color: #a5b4fc;
      cursor: default;
    }
    .actions button:hover:not(:disabled) {
      background-color: #c7d2fe;
    }
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 80px;
      background-color: #4338ca;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px 0;
      position: absolute;
      z-index: 10;
      bottom: 130%;
      left: 50%;
      margin-left: -40px;
      opacity: 0;
      transition: opacity 0.3s ease;
      user-select: none;
      font-size: 0.85rem;
      line-height: 1.2;
    }
    .tooltip:hover .tooltiptext,
    .tooltip:focus-within .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    #modal-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.4);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 20000;
      -webkit-overflow-scrolling: touch;
    }
    #modal {
      background: white;
      border-radius: 10px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.25);
      padding: 1.5rem;
      width: min(90vw, 600px);
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }
    #modal label {
      font-weight: 700;
      font-size: 1.1rem;
      margin-bottom: 1rem;
      user-select: none;
    }
    #modal-text {
      flex-grow: 1;
      width: 100%;
      resize: vertical;
      min-height: 200px;
      font-family: monospace;
      font-size: 1rem;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #bbb;
      outline: none;
      box-sizing: border-box;
      font-weight: 400;
      line-height: 1.4;
      user-select: text;
      -webkit-user-select: text;
    }
    #modal-text:focus {
      border-color: #4338ca;
      box-shadow: 0 0 8px #818cf8;
    }
    #modal-btns {
      display: flex;
      justify-content: flex-end;
      gap: 14px;
      margin-top: 1rem;
    }
    #modal-btns button {
      cursor: pointer;
      border-radius: 10px;
      padding: 8px 22px;
      font-weight: 600;
      font-size: 1rem;
      border: none;
      min-width: 90px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #modal-btns .cancel-btn {
      background-color: #e0e0e0;
      color: #333;
    }
    #modal-btns .cancel-btn:hover {
      background-color: #c0c0c0;
    }
    #modal-btns .save-btn {
      background-color: #4338ca;
      color: white;
      box-shadow: 0 0 12px #4338cacc;
    }
    #modal-btns .save-btn:hover {
      background-color: #2c23a9;
      box-shadow: 0 0 14px #2c23a9dd;
    }
    @media (max-width: 600px) {
      #bar {
        flex-direction: column;
        align-items: stretch;
      }
      #left-controls, #search, #color-picker {
        max-width: 100% !important;
        flex-grow: 1 !important;
      }
      .actions button {
        font-size: 1.25rem;
        padding: 5px 10px;
      }
      li {
        padding: 6px 12px;
      }
      #tree {
        font-size: 1.125rem;
      }
      .node-inner {
        padding: 10px 16px;
      }
    }
  </style>
</head>
<body>
  <div id="app" role="application" aria-label="超高機能ファイル構造エディタ">
    <h2>🚀 超安定・快適・高機能ファイル構造エディタ<br><small style="font-weight:400;">（縦画面スマホ対応・スクロールなし）</small></h2>
    <div id="bar" role="region" aria-label="ツールバー">
      <div id="left-controls">
        <select aria-label="プリセットテンプレート選択" id="template-select" title="プリセットテンプレート">
          <option value="">白紙から開始（空）</option>
          <option value="js">JavaScriptプロジェクト</option>
          <option value="web">Webサイト構成</option>
          <option value="docs">ドキュメント構成</option>
        </select>
        <button id="btn-add-folder" type="button" title="ルートに新規フォルダを追加">📁 フォルダ追加</button>
        <button id="btn-add-file" type="button" title="ルートに新規ファイルを追加">📄 ファイル追加</button>
        <button id="btn-save-json" type="button" title="現在の構造をJSONで保存">💾 保存</button>
        <button id="btn-load-json" type="button" title="JSONファイルを読み込む">📂 読込</button>
        <button id="btn-export-zip" type="button" title="構造をZIPファイルで出力">🗜 ZIP出力</button>
        <button id="btn-download-png" type="button" title="構造をPNG画像で出力">🖼 PNG出力</button>
      </div>
      <input id="search" type="search" autocomplete="off" placeholder="🔍 検索... (名前・内容対象)" aria-label="検索ボックス" />
      <div id="color-picker" title="選択中ノードの色を変更">
        <label for="color-input">🎨 色:</label>
        <input type="color" id="color-input" value="#ffffff" aria-label="ノード色選択"/>
      </div>
    </div>
    <div id="tree-container" tabindex="0" aria-label="ファイルツリー">
      <ul id="tree" role="tree" aria-live="polite" aria-relevant="additions removals"></ul>
    </div>
  </div>

  <!-- 内容編集モーダル -->
  <div id="modal-bg" role="dialog" aria-modal="true" aria-labelledby="modal-label" tabindex="-1">
    <div id="modal">
      <label id="modal-label" for="modal-text">内容編集</label>
      <textarea id="modal-text" aria-multiline="true" spellcheck="false"></textarea>
      <div id="modal-btns">
        <button class="cancel-btn" id="modal-cancel" type="button">キャンセル</button>
        <button class="save-btn" id="modal-ok" type="button">保存</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <script>
  (() => {
    const templates = {
      js: `/my-app
├── README.md
├── package.json
├── src/
│   └── index.js
└── tests/
    └── test.js`.trim(),

      web: `/site
├── index.html
├── assets/
│   ├── style.css
│   └── script.js`.trim(),

      docs: `/docs
├── README.md
├── guide.md
└── changelog.md`.trim()
    };

    let idCounter = 1;
    const genId = () => 'n' + (idCounter++);
    
    function createNode(name, type, color = '#ffffff', expanded = true) {
      return {
        id: genId(),
        name,
        type,
        color,
        expanded,
        children: type === 'folder' ? [] : null,
        content: type === 'file' ? '' : null
      };
    }

    let root = createNode('/', 'folder');
    let selectedId = null;
    let editingId = null;
    let draggedId = null;
    let dropPosition = null;
    let clipboard = null;
    let modalNode = null;

    const treeEl = document.getElementById('tree');
    const templateSelect = document.getElementById('template-select');
    const btnAddFolder = document.getElementById('btn-add-folder');
    const btnAddFile = document.getElementById('btn-add-file');
    const btnSaveJson = document.getElementById('btn-save-json');
    const btnLoadJson = document.getElementById('btn-load-json');
    const btnExportZip = document.getElementById('btn-export-zip');
    const btnDownloadPng = document.getElementById('btn-download-png');
    const searchInput = document.getElementById('search');
    const colorInput = document.getElementById('color-input');
    const modalBg = document.getElementById('modal-bg');
    const modalText = document.getElementById('modal-text');
    const modalCancel = document.getElementById('modal-cancel');
    const modalOk = document.getElementById('modal-ok');

    // ユーティリティ関数
    function findNodeById(node, id) {
      if (node.id === id) return node;
      if (node.type === 'folder' && node.children) {
        for (const c of node.children) {
          const found = findNodeById(c, id);
          if (found) return found;
        }
      }
      return null;
    }

    function findParentById(node, childId) {
      if (node.type !== 'folder' || !node.children) return null;
      for (const c of node.children) {
        if (c.id === childId) return node;
        const found = findParentById(c, childId);
        if (found) return found;
      }
      return null;
    }

    function cloneNode(node) {
      const copy = JSON.parse(JSON.stringify(node));
      (function renewIds(n){
        n.id = genId();
        if(n.type === 'folder' && n.children) n.children.forEach(renewIds);
      })(copy);
      return copy;
    }

    function nodeMatchesSearch(node, term) {
      if (!term || term.length < 1) return true;
      term = term.toLowerCase();
      if (node.name.toLowerCase().includes(term)) return true;
      if (node.type === 'file' && node.content && node.content.toLowerCase().includes(term)) return true;
      if (node.type === 'folder' && node.children) {
        return node.children.some((c) => nodeMatchesSearch(c, term));
      }
      return false;
    }

    function getFileTemplate(name) {
      if (name.match(/\.html?$/i)) return `<!DOCTYPE html>
<html lang="ja">
<head><meta charset="UTF-8"><title>${name.replace(/\.html?$/i, '')}</title></head>
<body>
</body>
</html>`;
      if (name.match(/\.js$/i)) return `// ${name}\nconsole.log('Hello, world!');`;
      if (name.match(/\.css$/i)) return `/* ${name} */\nbody {\n  margin: 0;\n}\n`;
      return '';
    }

    function getContrastYIQ(hexcolor) {
      if (!hexcolor) return '#000000';
      hexcolor = hexcolor.replace("#", "");
      const r = parseInt(hexcolor.substr(0,2),16);
      const g = parseInt(hexcolor.substr(2,2),16);
      const b = parseInt(hexcolor.substr(4,2),16);
      const yiq = (r*299 + g*587 + b*114) / 1000;
      return yiq >= 128 ? '#000000' : '#FFFFFF';
    }

    function isDescendant(parentNode, possibleDescendant) {
      if (parentNode.type !== 'folder') return false;
      for (const c of parentNode.children) {
        if (c.id === possibleDescendant.id) return true;
        if (c.type === 'folder' && isDescendant(c, possibleDescendant)) return true;
      }
      return false;
    }

    function clearDragClasses() {
      document.querySelectorAll('#tree li').forEach(el => {
        el.classList.remove('over-drop-before', 'over-drop-after', 'over-drop-inside');
      });
    }

    // モーダル関数
    function openModal(node) {
      if (node.type !== 'file') return;
      modalNode = node;
      modalText.value = node.content || '';
      modalBg.style.display = 'flex';
      modalText.focus();
    }

    function closeModal() {
      modalBg.style.display = 'none';
      modalNode = null;
    }

    // CRUD操作関数
    function deleteSelectedNode() {
      if (!selectedId) return;
      const parent = findParentById(root, selectedId);
      if (!parent) return;
      const index = parent.children.findIndex(c => c.id === selectedId);
      if (index >= 0) {
        parent.children.splice(index, 1);
        selectedId = null;
        editingId = null;
        render();
        updateColorPicker();
      }
    }

    function copySelectedNode() {
      if (!selectedId) return;
      const node = findNodeById(root, selectedId);
      if (node) {
        clipboard = cloneNode(node);
        render();
      }
    }

    function pasteNode(targetNode) {
      if (!clipboard || targetNode.type !== 'folder') return;
      targetNode.children.push(cloneNode(clipboard));
      targetNode.expanded = true;
      render();
    }

    function parseTemplate(template) {
      const lines = template.split('\n');
      const stack = [{ node: root, level: -1 }];
      
      for (const line of lines) {
        const match = line.match(/^(\s*)([├└│─\s]*)(.*?)(\/$)?$/);
        if (!match) continue;
        
        const [, indent, , name] = match;
        const isFolder = line.endsWith('/');
        const level = Math.floor(indent.length / 4);
        
        while (stack.length > level + 1) {
          stack.pop();
        }
        
        const parent = stack[stack.length - 1].node;
        const newNode = createNode(name, isFolder ? 'folder' : 'file');
        
        if (newNode.type === 'file') {
          newNode.content = getFileTemplate(newNode.name);
        }
        
        parent.children.push(newNode);
        
        if (isFolder) {
          stack.push({ node: newNode, level });
        }
      }
    }

    // 色更新関数
    function updateColorPicker() {
      if (!selectedId) {
        colorInput.disabled = true;
        colorInput.value = '#ffffff';
      } else {
        colorInput.disabled = false;
        const node = findNodeById(root, selectedId);
        colorInput.value = node?.color || '#ffffff';
      }
    }

    // ファイル保存・読み込み関数
    function downloadFile(content, filename) {
      const blob = new Blob([content], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function saveAsJSON() {
      const json = JSON.stringify(root, null, 2);
      downloadFile(json, 'file-structure.json');
    }

    function loadFromJSON() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            root = data;
            selectedId = null;
            editingId = null;
            render();
            updateColorPicker();
          } catch (err) {
            alert('JSONファイルの読み込みに失敗しました: ' + err.message);
          }
        };
        reader.readAsText(file);
      };
      input.click();
    }

    function exportAsZip() {
      if (typeof JSZip === 'undefined') {
        alert('JSZipライブラリが読み込まれていません');
        return;
      }
      
      const zip = new JSZip();
      
      function addToZip(node, path = '') {
        const fullPath = path + node.name + (node.type === 'folder' ? '/' : '');
        
        if (node.type === 'file') {
          zip.file(fullPath, node.content || '');
        } else if (node.type === 'folder') {
          if (node.children && node.children.length > 0) {
            node.children.forEach(child => addToZip(child, fullPath));
          } else {
            zip.folder(fullPath);
          }
        }
      }
      
      if (root.children) {
        root.children.forEach(child => addToZip(child));
      }
      
      zip.generateAsync({ type: 'blob' })
        .then(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'file-structure.zip';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
    }

    function downloadAsPNG() {
      if (typeof html2canvas === 'undefined') {
        alert('html2canvasライブラリが読み込まれていません');
        return;
      }
      
      html2canvas(document.getElementById('tree-container')).then(canvas => {
        const link = document.createElement('a');
        link.download = 'file-structure.png';
        link.href = canvas.toDataURL();
        link.click();
      });
    }

    // 描画関数
    function render() {
      treeEl.innerHTML = '';
      
      function build(node, container) {
        if (!node.children) return;
        
        node.children.forEach(child => {
          if (!nodeMatchesSearch(child, searchInput.value.trim())) return;
          
          const li = document.createElement('li');
          li.setAttribute('role', 'treeitem');
          li.dataset.id = child.id;
          li.setAttribute('tabindex', '0');
          li.setAttribute('aria-expanded', child.type === 'folder' ? String(child.expanded) : undefined);
          li.classList.remove('dragging', 'over-drop-before', 'over-drop-after', 'over-drop-inside');
          
          // トグルボタンまたはスペーサー
          if (child.type === 'folder') {
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'toggle-btn';
            toggleBtn.setAttribute('aria-label', child.expanded ? '折り畳む' : '展開する');
            toggleBtn.textContent = child.expanded ? '▼' : '▶';
            toggleBtn.addEventListener('click', e => {
              child.expanded = !child.expanded;
              render();
              e.stopPropagation();
            });
            li.appendChild(toggleBtn);
          } else {
            const spacer = document.createElement('span');
            spacer.style.width = '1.35rem';
            li.appendChild(spacer);
          }
          
          // 編集中の場合は入力フィールドを表示
          if (editingId === child.id) {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = child.name;
            input.className = 'node-inner';
            input.style.flexGrow = '1';
            li.appendChild(input);
            input.focus();
            input.select();
            
            input.addEventListener('blur', e => {
              const val = e.target.value.trim();
              if (val.length > 0) child.name = val;
              editingId = null;
              render();
            });
            
            input.addEventListener('keydown', e => {
              if (e.key === 'Enter') input.blur();
              if (e.key === 'Escape') { 
                editingId = null; 
                render(); 
              }
            });
          } else {
            // ノードの表示
            const nodeInner = document.createElement('div');
            nodeInner.className = 'node-inner' + (child.id === selectedId ? ' selected' : '');
            nodeInner.tabIndex = 0;
            
            const icon = document.createElement('span');
            icon.className = 'node-type-icon tooltip';
            icon.textContent = child.type === 'folder' ? '📁' : '📄';
            const tooltip = document.createElement('span');
            tooltip.className = 'tooltiptext';
            tooltip.textContent = child.type === 'folder' ? 'フォルダ' : 'ファイル';
            icon.appendChild(tooltip);
            nodeInner.appendChild(icon);
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'node-name';
            nameSpan.textContent = child.name + (child.type === 'folder' ? '/' : '');
            nodeInner.appendChild(nameSpan);
            
            if (child.color && child.color !== '#ffffff') {
              nodeInner.style.backgroundColor = child.color;
              nodeInner.style.color = getContrastYIQ(child.color);
            } else {
              nodeInner.style.backgroundColor = '';
              nodeInner.style.color = '';
            }
            
            nodeInner.addEventListener('click', e => {
              e.stopPropagation();
              selectedId = child.id;
              editingId = null;
              updateColorPicker();
              render();
            });
            
            nodeInner.addEventListener('dblclick', e => {
              e.stopPropagation();
              if (child.type === 'file') {
                openModal(child);
              } else {
                child.expanded = !child.expanded;
                render();
              }
            });
            
            li.appendChild(nodeInner);
          }
          
          // アクションボタン
          const actions = document.createElement('span');
          actions.className = 'actions';

          const btnRename = document.createElement('button');
          btnRename.innerText = '✎';
          btnRename.title = '名前変更 (F2)';
          btnRename.addEventListener('click', e => {
            e.stopPropagation();
            editingId = child.id;
            render();
          });
          actions.appendChild(btnRename);
          
          if (child.type === 'folder') {
            const btnAddFolder = document.createElement('button');
            btnAddFolder.innerText = '📁＋';
            btnAddFolder.title = 'フォルダ作成';
            btnAddFolder.addEventListener('click', e => {
              e.stopPropagation();
              child.children.push(createNode('新しいフォルダ', 'folder'));
              child.expanded = true;
              render();
            });
            actions.appendChild(btnAddFolder);
            
            const btnAddFile = document.createElement('button');
            btnAddFile.innerText = '📄＋';
            btnAddFile.title = 'ファイル作成';
            btnAddFile.addEventListener('click', e => {
              e.stopPropagation();
              const newFile = createNode('新しいファイル.txt', 'file');
              newFile.content = getFileTemplate(newFile.name);
              child.children.push(newFile);
              child.expanded = true;
              render();
            });
            actions.appendChild(btnAddFile);
          }
          
          const btnContentEdit = document.createElement('button');
          btnContentEdit.innerText = '📝';
          btnContentEdit.title = '内容編集';
          btnContentEdit.disabled = child.type !== 'file';
          btnContentEdit.addEventListener('click', e => {
            e.stopPropagation();
            if (child.type === 'file') openModal(child);
          });
          actions.appendChild(btnContentEdit);
          
          const btnDelete = document.createElement('button');
          btnDelete.innerText = '✕';
          btnDelete.title = '削除 (Delete)';
          btnDelete.addEventListener('click', e => {
            e.stopPropagation();
            selectedId = child.id;
            deleteSelectedNode();
          });
          actions.appendChild(btnDelete);
          
          const btnCopy = document.createElement('button');
          btnCopy.innerText = '📋';
          btnCopy.title = 'コピー (Ctrl+C)';
          btnCopy.addEventListener('click', e => {
            e.stopPropagation();
            selectedId = child.id;
            copySelectedNode();
          });
          actions.appendChild(btnCopy);
          
          const btnPaste = document.createElement('button');
          btnPaste.innerText = '📥';
          btnPaste.title = 'ペースト (Ctrl+V)';
          btnPaste.disabled = clipboard === null || child.type !== 'folder';
          btnPaste.addEventListener('click', e => {
            e.stopPropagation();
            pasteNode(child);
          });
          actions.appendChild(btnPaste);
          
          li.appendChild(actions);
          container.appendChild(li);
          
          // 子要素の表示
          if (child.type === 'folder' && child.expanded && child.children && child.children.length > 0) {
            const ul = document.createElement('ul');
            ul.className = 'children';
            ul.setAttribute('role', 'group');
            li.appendChild(ul);
            build(child, ul);
          }
        });
      }
      
      build(root, treeEl);
    }

    // イベントリスナー設定
    
    // テンプレート選択
    templateSelect.addEventListener('change', e => {
      const template = templates[e.target.value];
      if (template) {
        root = createNode('/', 'folder');
        parseTemplate(template);
        selectedId = null;
        editingId = null;
        render();
        updateColorPicker();
      }
    });

    // ルートレベルの追加ボタン
    btnAddFolder.addEventListener('click', () => {
      root.children.push(createNode('新しいフォルダ', 'folder'));
      root.expanded = true;
      selectedId = root.children[root.children.length - 1].id;
      editingId = null;
      render();
      updateColorPicker();
    });

    btnAddFile.addEventListener('click', () => {
      const newFile = createNode('新しいファイル.txt', 'file');
      newFile.content = getFileTemplate(newFile.name);
      root.children.push(newFile);
      root.expanded = true;
      selectedId = root.children[root.children.length - 1].id;
      editingId = null;
      render();
      updateColorPicker();
    });

    // ファイル操作ボタン
    btnSaveJson.addEventListener('click', saveAsJSON);
    btnLoadJson.addEventListener('click', loadFromJSON);
    btnExportZip.addEventListener('click', exportAsZip);
    btnDownloadPng.addEventListener('click', downloadAsPNG);

    // 検索機能
    searchInput.addEventListener('input', () => render());

    // 色変更機能
    colorInput.addEventListener('input', e => {
      if (!selectedId) return;
      const node = findNodeById(root, selectedId);
      if (!node) return;
      node.color = e.target.value;
      
      // フォルダの場合は子要素にも適用
      if (node.type === 'folder') {
        function recolor(n) {
          if (n.children) {
            n.children.forEach(c => {
              c.color = node.color;
              if (c.type === 'folder') recolor(c);
            });
          }
        }
        recolor(node);
      }
      render();
    });

    // モーダル機能
    modalCancel.addEventListener('click', closeModal);
    modalOk.addEventListener('click', () => {
      if (modalNode) {
        modalNode.content = modalText.value;
      }
      closeModal();
    });

    modalBg.addEventListener('click', e => {
      if (e.target === modalBg) closeModal();
    });

    // キーボードショートカット
    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      switch (e.key) {
        case 'F2':
          if (selectedId) {
            editingId = selectedId;
            render();
          }
          e.preventDefault();
          break;
        case 'Delete':
          if (selectedId) {
            deleteSelectedNode();
          }
          e.preventDefault();
          break;
        case 'c':
          if (e.ctrlKey && selectedId) {
            copySelectedNode();
            e.preventDefault();
          }
          break;
        case 'v':
          if (e.ctrlKey && selectedId && clipboard) {
            const node = findNodeById(root, selectedId);
            if (node && node.type === 'folder') {
              pasteNode(node);
            }
            e.preventDefault();
          }
          break;
        case 'Escape':
          if (modalBg.style.display === 'flex') {
            closeModal();
          }
          break;
      }
    });

    // 初期化
    render();
    updateColorPicker();

  })();
  </script>
</body>
</html>