<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>進化版掲示板システム Pro</title>
  <style>
    :root{
      --primary-color:#007acc;
      --primary-dark:#005fa3;
      --primary-darker:#004080;
      --success-color:#28a745;
      --warning-color:#ffc107;
      --danger-color:#dc3545;
      --info-color:#17a2b8;
      --light-color:#f8f9fa;
      --dark-color:#343a40;
      --bg-color:#f4f4f4;
      --text-color:#333;
      --border-color:#ddd;
      --shadow:0 2px 4px rgba(0,0,0,0.1);
      --shadow-hover:0 4px 8px rgba(0,0,0,0.15);
      --transition:all 0.3s ease;
      --border-radius:8px;
      --font-size-small:0.85rem;
      --font-size-normal:1rem;
      --font-size-large:1.2rem;
      --header-padding:12px;
    }

    .dark-mode{
      --bg-color:#1a1a1a;
      --text-color:#e0e0e0;
      --border-color:#444;
      --light-color:#2d2d2d;
      --dark-color:#121212;
      --primary-color:#4da6ff;
      --primary-dark:#3b89e0;
      --primary-darker:#2c6eb5;
      --info-color:#20c997;
      --success-color:#20c997;
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;width:100%;}

    /* Prevent page/body scrolling: keep single-viewport app */
    body{
      font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background:var(--bg-color);
      color:var(--text-color);
      transition:var(--transition);
      line-height:1.45;
      height:100vh;          /* lock to viewport */
      overflow:hidden;       /* prevent page scroll */
      -webkit-overflow-scrolling:touch;
      -webkit-text-size-adjust:100%;
      -ms-text-size-adjust:100%;
    }

    /* Header: three-row button layout using CSS grid */
    header{
      background:linear-gradient(135deg,var(--primary-color),var(--primary-dark));
      padding:var(--header-padding);
      box-shadow:var(--shadow);
      position:sticky;
      top:0;
      z-index:60;
    }

    .header-content{
      max-width:1400px;
      margin:0 auto;
    }

    /* Make header buttons flow into exactly three rows.
       Use a responsive grid with three explicit rows, each row auto-fitting columns.
       Buttons will wrap and remain accessible without causing body scroll. */
    .header-row{
      display:grid;
      grid-template-rows: repeat(3, auto);
      grid-auto-flow: row;
      gap:8px;
      align-items:center;
      justify-items:center;
      row-gap:8px;
      padding:4px;
    }

    .header-row .row{
      width:100%;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:center;
      align-items:center;
    }

    .header-btn{
      padding:10px 12px;
      border:none;
      border-radius:var(--border-radius);
      background:var(--primary-dark);
      color:white;
      cursor:pointer;
      transition:var(--transition);
      font-size:var(--font-size-small);
      font-weight:500;
      white-space:nowrap;
      flex:0 1 auto;
      min-width:48px;
    }

    .header-btn:hover{background:var(--primary-darker);transform:translateY(-2px);box-shadow:var(--shadow-hover);}
    .header-btn.active{background:var(--success-color);}

    .header-input{
      padding:8px 12px;
      border:2px solid rgba(255,255,255,0.3);
      border-radius:var(--border-radius);
      background:rgba(255,255,255,0.1);
      color:white;
      font-size:var(--font-size-small);
      transition:var(--transition);
      min-width:160px;
    }

    .header-input::placeholder{color:rgba(255,255,255,0.7);}
    .header-input:focus{outline:none;background:rgba(255,255,255,0.18);border-color:rgba(255,255,255,0.5);}

    /* Main layout: stack without causing the body to scroll.
       We use a column flex layout filling remaining viewport height. */
    main{
      height:calc(100vh -  (var(--header-height, 160px) * 0)); /* fallback; actual height controlled by flex */
      display:flex;
      flex-direction:column;
      gap:0;
      align-items:stretch;
      justify-content:flex-start;
      max-width:1400px;
      margin:0 auto;
      padding:10px;
      height:calc(100vh -  ( (var(--header-padding) * 2) + 24px)); /* conservative reserve to avoid overlap */
    }

    /* New post area fixed height to keep total content fit in viewport */
    .new-post-section{
      background:var(--light-color);
      padding:12px;
      border-bottom:1px solid var(--border-color);
      box-shadow:var(--shadow);
      border-radius:8px;
      flex:0 0 auto;
      display:flex;
      align-items:flex-start;
      gap:10px;
    }

    .new-post-container{
      width:100%;
      display:grid;
      grid-template-columns:1fr auto;
      gap:12px;
      align-items:start;
    }

    .new-post-input{
      width:100%;
      padding:10px;
      border:2px solid var(--border-color);
      border-radius:var(--border-radius);
      resize:vertical;
      font-family:inherit;
      font-size:var(--font-size-normal);
      transition:var(--transition);
      min-height:78px;
      max-height:140px;
      overflow:auto;
      background:var(--bg-color);
      color:var(--text-color);
    }
    .new-post-input:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 3px rgba(0,122,204,0.08);}

    .new-post-controls{display:flex;flex-direction:column;gap:10px;align-items:stretch;}
    .control-btn{padding:10px 14px;border:none;border-radius:var(--border-radius);font-weight:600;cursor:pointer;transition:var(--transition);white-space:nowrap;}
    .btn-primary{background:var(--success-color);color:white;}
    .btn-primary:hover{background:#218838}
    .btn-secondary{background:var(--warning-color);color:var(--dark-color);}

    /* Posts area takes remaining vertical space; internal scrolling allowed (but page won't scroll). */
    .posts-section{
      flex:1 1 auto;
      overflow:auto;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      -webkit-overflow-scrolling:touch;
    }

    .post{background:var(--light-color);border:1px solid var(--border-color);border-radius:var(--border-radius);padding:14px;transition:var(--transition);position:relative;box-shadow:var(--shadow);cursor:move;}
    .post:hover{box-shadow:var(--shadow-hover);transform:translateY(-2px);}
    .post.pinned{border-left:5px solid var(--success-color);background:linear-gradient(135deg,var(--light-color),#f0fff0);}

    .post-header{display:flex;flex-wrap:wrap;justify-content:space-between;align-items:center;margin-bottom:10px;gap:8px;}
    .post-meta{display:flex;flex-wrap:wrap;gap:12px;align-items:center;font-size:var(--font-size-small);color:#666;}
    .post-stats{display:flex;gap:10px;align-items:center;font-size:var(--font-size-small);}
    .stat-item{display:flex;align-items:center;gap:4px;padding:4px 8px;background:rgba(0,122,204,0.08);border-radius:12px;color:var(--primary-color);font-weight:500;}

    .post-actions{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;}
    .post-btn{padding:6px 12px;border:none;border-radius:16px;font-size:0.8rem;cursor:pointer;transition:var(--transition);font-weight:500;}
    .btn-favorite{background:#fff3cd;color:#856404;border:1px solid #ffeaa7;}
    .btn-favorite.active{background:#ffc107;color:white;}
    .btn-reply{background:#d1ecf1;color:#0c5460;border:1px solid #bee5eb;}
    .btn-edit{background:#e2e3e5;color:#383d41;border:1px solid #d6d8db;}
    .btn-delete{background:#f8d7da;color:#721c24;border:1px solid #f1b0b7;}
    .post-btn:hover{transform:translateY(-1px);box-shadow:0 2px 4px rgba(0,0,0,0.08);}

    .post-content{font-size:var(--font-size-normal);line-height:1.6;margin-bottom:8px;word-wrap:break-word;white-space:pre-wrap;}

    .post-tags{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px;}
    .tag{padding:4px 10px;background:linear-gradient(135deg,var(--info-color),#20c997);color:white;border-radius:16px;font-size:0.8rem;font-weight:500;cursor:pointer;transition:var(--transition);}

    /* Sidebars and panels kept as-is but positioned within viewport; they may scroll internally */
    .sidebar-panel{position:fixed;top:120px;right:20px;background:var(--light-color);border:1px solid var(--border-color);border-radius:var(--border-radius);padding:16px;max-width:320px;max-height:60vh;overflow:auto;box-shadow:var(--shadow-hover);z-index:40;transform:translateX(400px);transition:transform 0.3s ease;}
    .sidebar-panel.visible{transform:translateX(0);}

    .panel-header{font-size:var(--font-size-large);font-weight:700;margin-bottom:12px;color:var(--primary-color);border-bottom:2px solid var(--primary-color);padding-bottom:8px;}

    .overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);backdrop-filter:blur(3px);z-index:98;opacity:0;visibility:hidden;transition:var(--transition);}
    .overlay.visible{opacity:1;visibility:visible;}

    /*
      CRITICAL FIX:
      - Non-visible panels (settings-panel, advanced-filter-panel) previously accepted pointer events even when hidden (opacity:0/transform),
        causing invisible inputs (type=date) to receive focus/taps, resulting in calendar appearing and blocking textarea input.
      - Solution: default pointer-events:none; when panel has .visible, enable pointer-events:auto.
    */
    .settings-panel, .advanced-filter-panel{
      position:fixed;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%) scale(0.95);
      background:var(--light-color);
      border-radius:var(--border-radius);
      padding:20px;
      width:92%;
      max-width:640px;
      max-height:80vh;
      overflow:auto;
      box-shadow:0 20px 60px rgba(0,0,0,0.3);
      z-index:99;
      transition:var(--transition);
      opacity:0;
      pointer-events:none;           /* <-- make non-interactive when hidden */
      -webkit-user-select:none;
      user-select:none;
    }
    .settings-panel.visible, .advanced-filter-panel.visible{
      transform:translate(-50%,-50%) scale(1);
      opacity:1;
      pointer-events:auto;           /* <-- interactive only when visible */
      -webkit-user-select:auto;
      user-select:auto;
    }

    .notification{position:fixed;top:16px;right:16px;padding:12px 14px;border-radius:var(--border-radius);color:white;font-weight:600;z-index:101;transform:translateX(400px);transition:var(--transition);min-width:220px;box-shadow:var(--shadow-hover);}
    .notification.visible{transform:translateX(0);}
    .notification.success{background:linear-gradient(135deg,var(--success-color),#20c997);}
    .notification.error{background:linear-gradient(135deg,var(--danger-color),#e83e8c);}
    .notification.info{background:linear-gradient(135deg,var(--info-color),var(--primary-color));}
    .close-notification{margin-left:10px;font-size:1.1rem;cursor:pointer;font-weight:bold;}

    /* Compact UI adjustments for small portrait screens */
    @media (max-width: 420px) and (orientation: portrait) {
      header{padding:10px;}
      .header-row .row{gap:6px;}
      .header-btn{padding:8px 10px;font-size:0.82rem;min-width:40px;}
      .header-input{min-width:120px;font-size:0.86rem;padding:6px 8px;}
      .new-post-input{min-height:70px;max-height:120px;font-size:0.95rem;}
      .new-post-section{padding:10px;}
      .sidebar-panel{right:8px;top:110px;max-width:300px;max-height:55vh;}
      .posts-section{padding:8px;gap:10px;}
      .post{padding:10px;}
      .panel-header{font-size:1.05rem;}
      main{padding:8px;height:calc(100vh -  ( (var(--header-padding) * 2) + 16px));}
    }

    @media (min-width: 900px){
      .new-post-input{max-height:160px}
      .sidebar-panel{max-width:340px;top:140px;}
    }

    /* Utility */
    .hidden{display:none!important}
    .fade-in{animation:fadeIn 0.25s ease}
    @keyframes fadeIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}
    .tag-removable{cursor:pointer;margin-left:6px;font-weight:bold}
    .image-preview{max-width:180px;max-height:120px;border-radius:8px;margin-top:8px;box-shadow:var(--shadow)}
    .filter-input{padding:8px 12px;border:1px solid var(--border-color);border-radius:var(--border-radius);width:100%;margin-bottom:10px;background:var(--bg-color);color:var(--text-color)}
  </style>
</head>
<body>
  <header id="global-header">
    <div class="header-content">
      <div class="header-row top" id="btn-container">
        <div class="row" style="justify-content:center;">
          <button id="btn-dark-mode" class="header-btn" title="ダークモード切替">🌙 ダーク</button>
          <button id="btn-sort-new" class="header-btn active" title="新しい順">📅 新しい順</button>
          <button id="btn-sort-old" class="header-btn" title="古い順">📆 古い順</button>
          <button id="btn-sort-popular" class="header-btn" title="人気順">⭐ 人気順</button>
        </div>

        <div class="row" style="justify-content:center;">
          <button id="btn-advanced-filter" class="header-btn" title="高度なフィルター">🔍 高度検索</button>
          <input type="text" id="search-input" class="header-input" placeholder="🔍 リアルタイム検索...">
          <button id="btn-favorites" class="header-btn" title="お気に入り">⭐ お気に入り</button>
          <button id="btn-archives" class="header-btn" title="アーカイブ">📦 アーカイブ</button>
        </div>

        <div class="row" style="justify-content:center;">
          <button id="btn-notifications" class="header-btn" title="通知センター">🔔 通知</button>
          <button id="btn-statistics" class="header-btn" title="統計">📊 統計</button>
          <button id="btn-export" class="header-btn" title="エクスポート">📤 出力</button>
          <button id="btn-undo" class="header-btn" title="元に戻す (Ctrl+Z)">↶ 戻す</button>
          <button id="btn-redo" class="header-btn" title="やり直し (Ctrl+Y)">↷ 進む</button>
          <button id="btn-settings" class="header-btn" title="設定">⚙️ 設定</button>
        </div>
      </div>
    </div>
  </header>

  <main>
    <section class="new-post-section">
      <div class="new-post-container">
        <div>
          <textarea id="new-post-input" class="new-post-input" placeholder="💭 新しい投稿を入力... (Markdown対応: # 見出し, - リスト, ```コード```)" rows="4"></textarea>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center;flex-wrap:wrap;">
            <input type="text" id="tag-input" class="filter-input" placeholder="タグ (スペース区切り)" style="width:220px;">
            <button id="add-tag-btn" class="post-btn">🏷️ タグ追加</button>
            <input type="file" id="image-input" accept="image/*" style="display:none;">
            <button id="add-image-btn" class="post-btn btn-edit">🖼️ 画像添付</button>
            <img id="image-preview" class="image-preview" style="display:none;">
          </div>
          <div id="current-tags" class="post-tags" style="margin-top:8px;"></div>
        </div>
        <div class="new-post-controls">
          <button id="post-btn" class="control-btn btn-primary">📝 投稿 (Ctrl+Enter)</button>
        </div>
      </div>
    </section>

    <section id="posts-container" class="posts-section"></section>

    <section class="tag-filter-section" id="tag-filter-section" style="flex:0 0 auto;">
      <div class="tag-filter-container">
        <h3 style="margin-bottom:8px;color:var(--primary-color);">🏷️ タグでフィルター</h3>
        <div id="tag-filter"></div>
      </div>
    </section>
  </main>

  <aside id="favorites-panel" class="sidebar-panel">
    <div class="panel-header">⭐ お気に入り一覧</div>
    <div id="favorites-list"></div>
  </aside>

  <aside id="archives-panel" class="sidebar-panel">
    <div class="panel-header">📦 アーカイブ一覧</div>
    <div id="archives-list"></div>
  </aside>

  <aside id="notifications-panel" class="sidebar-panel">
    <div class="panel-header">🔔 通知センター</div>
    <button id="clear-notifications" class="control-btn btn-secondary" style="width:100%;margin-bottom:10px;">通知をクリア</button>
    <div id="notifications-list"></div>
  </aside>

  <aside id="statistics-panel" class="sidebar-panel">
    <div class="panel-header">📊 統計情報</div>
    <div id="statistics-content"></div>
  </aside>

  <div id="overlay" class="overlay"></div>

  <div id="settings-panel" class="settings-panel">
    <div class="settings-section">
      <label class="settings-label">⚙️ 設定</label>
      <button id="export-settings" class="control-btn btn-secondary" style="width:100%;margin-bottom:10px;">設定をエクスポート</button>
      <button id="import-settings" class="control-btn btn-secondary" style="width:100%;">設定をインポート</button>
    </div>
    <div class="settings-section">
      <label class="settings-label">⌨️ キーボードショートカット</label>
      <div class="keyboard-shortcuts">
        <div class="shortcut-item"><span>新規投稿</span><span class="shortcut-key">Ctrl + Enter</span></div>
        <div class="shortcut-item"><span>検索フォーカス</span><span class="shortcut-key">Ctrl + F</span></div>
        <div class="shortcut-item"><span>元に戻す</span><span class="shortcut-key">Ctrl + Z</span></div>
        <div class="shortcut-item"><span>やり直し</span><span class="shortcut-key">Ctrl + Y</span></div>
        <div class="shortcut-item"><span>ダークモード切替</span><span class="shortcut-key">Ctrl + D</span></div>
      </div>
    </div>
  </div>

  <div id="advanced-filter-panel" class="advanced-filter-panel">
    <div class="settings-section">
      <label class="settings-label">🔍 高度なフィルター</label>
      <label style="display:block;margin-bottom:5px;">日付範囲</label>
      <input type="date" id="date-from" class="filter-input">
      <input type="date" id="date-to" class="filter-input">
      <label style="display:block;margin:15px 0 5px 0;">タグ (複数選択可)</label>
      <div id="tag-checkboxes" style="max-height:200px;overflow-y:auto;border:1px solid var(--border-color);padding:10px;border-radius:8px;"></div>
      <label style="display:block;margin:15px 0 5px 0;"><input type="checkbox" id="filter-favorites"> お気に入りのみ表示</label>
      <label style="display:block;margin:10px 0 5px 0;"><input type="checkbox" id="filter-pinned"> ピン留めのみ表示</label>
      <div style="display:flex;gap:10px;margin-top:20px;">
        <button id="apply-advanced-filter" class="control-btn btn-primary" style="flex:1;">フィルター適用</button>
        <button id="reset-advanced-filter" class="control-btn btn-secondary" style="flex:1;">リセット</button>
      </div>
    </div>
  </div>

  <input type="file" id="import-settings-input" style="display:none;" accept=".json">
  <div id="notification-area"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // DOM Elements
      const postsContainer = document.getElementById('posts-container');
      const newPostInput = document.getElementById('new-post-input');
      const postBtn = document.getElementById('post-btn');
      const searchInput = document.getElementById('search-input');
      const tagInput = document.getElementById('tag-input');
      const addTagBtn = document.getElementById('add-tag-btn');
      const currentTagsContainer = document.getElementById('current-tags');
      const tagFilterContainer = document.getElementById('tag-filter');
      const darkModeBtn = document.getElementById('btn-dark-mode');
      const sortNewBtn = document.getElementById('btn-sort-new');
      const sortOldBtn = document.getElementById('btn-sort-old');
      const sortPopularBtn = document.getElementById('btn-sort-popular');
      const favoritesBtn = document.getElementById('btn-favorites');
      const archivesBtn = document.getElementById('btn-archives');
      const notificationsBtn = document.getElementById('btn-notifications');
      const statisticsBtn = document.getElementById('btn-statistics');
      const favoritesPanel = document.getElementById('favorites-panel');
      const archivesPanel = document.getElementById('archives-panel');
      const notificationsPanel = document.getElementById('notifications-panel');
      const statisticsPanel = document.getElementById('statistics-panel');
      const favoritesList = document.getElementById('favorites-list');
      const archivesList = document.getElementById('archives-list');
      const notificationsList = document.getElementById('notifications-list');
      const statisticsContent = document.getElementById('statistics-content');
      const settingsBtn = document.getElementById('btn-settings');
      const settingsPanel = document.getElementById('settings-panel');
      const overlay = document.getElementById('overlay');
      const undoBtn = document.getElementById('btn-undo');
      const redoBtn = document.getElementById('btn-redo');
      const exportBtn = document.getElementById('btn-export');
      const notificationArea = document.getElementById('notification-area');
      const advancedFilterBtn = document.getElementById('btn-advanced-filter');
      const advancedFilterPanel = document.getElementById('advanced-filter-panel');
      const imageInput = document.getElementById('image-input');
      const addImageBtn = document.getElementById('add-image-btn');
      const imagePreview = document.getElementById('image-preview');
      const clearNotificationsBtn = document.getElementById('clear-notifications');

      // State
      let posts = [];
      let currentTags = [];
      let historyStack = [];
      let historyIndex = -1;
      let deletedPosts = [];
      let currentSort = 'new';
      let currentFilterTag = null;
      let currentSearchQuery = '';
      let notificationHistory = [];
      let currentImage = null;
      let advancedFilters = {
        dateFrom: null,
        dateTo: null,
        tags: [],
        favoritesOnly: false,
        pinnedOnly: false
      };
      let draggedPost = null;

      // Post Class
      class Post {
        constructor(content, tags = [], parentId = null, image = null) {
          this.id = Date.now() + Math.random();
          this.content = content;
          this.timestamp = new Date().toISOString();
          this.tags = tags;
          this.replies = [];
          this.parentId = parentId;
          this.favorites = 0;
          this.isFavorite = false;
          this.isPinned = false;
          this.isArchived = false;
          this.image = image;
        }
      }

      // Persistence
      const saveState = () => {
        try {
          const state = { posts, deletedPosts, notificationHistory };
          localStorage.setItem('boardPosts', JSON.stringify(state));
        } catch (e) {
          showNotification('データの保存に失敗しました。', 'error');
        }
      };

      const loadState = () => {
        try {
          const stored = localStorage.getItem('boardPosts');
          if (stored) {
            const state = JSON.parse(stored);
            posts = state.posts || [];
            deletedPosts = state.deletedPosts || [];
            notificationHistory = state.notificationHistory || [];
          }
        } catch (e) {
          showNotification('データの読み込みに失敗しました。', 'error');
        }
      };

      // History
      const saveHistory = () => {
        historyStack = historyStack.slice(0, historyIndex + 1);
        historyStack.push(JSON.stringify({ posts, deletedPosts }));
        historyIndex = historyStack.length - 1;
        if (historyStack.length > 50) {
          historyStack.shift();
          historyIndex--;
        }
        updateHistoryButtons();
      };

      const undo = () => {
        if (historyIndex > 0) {
          historyIndex--;
          const prevState = JSON.parse(historyStack[historyIndex]);
          posts = prevState.posts;
          deletedPosts = prevState.deletedPosts;
          renderPosts();
          showNotification('元に戻しました。', 'info');
          updateHistoryButtons();
        }
      };

      const redo = () => {
        if (historyIndex < historyStack.length - 1) {
          historyIndex++;
          const nextState = JSON.parse(historyStack[historyIndex]);
          posts = nextState.posts;
          deletedPosts = nextState.deletedPosts;
          renderPosts();
          showNotification('やり直しました。', 'info');
          updateHistoryButtons();
        }
      };

      const updateHistoryButtons = () => {
        undoBtn.disabled = historyIndex <= 0;
        redoBtn.disabled = historyIndex >= historyStack.length - 1;
      };

      // Markdown Parser
      const parseMarkdown = (text) => {
        let html = text;
        html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
        html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
        html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
        html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
        html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
        html = html.replace(/^\- (.*$)/gm, '<li>$1</li>');
        html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
        html = html.replace(/`(.*?)`/g, '<code>$1</code>');
        return html;
      };

      // Render Posts
      const renderPosts = () => {
        postsContainer.innerHTML = '';
        const sortedPosts = sortPosts(filterPosts(posts));
        sortedPosts.forEach((post, index) => {
          if (!post.isArchived) {
            const postEl = createPostElement(post, index);
            postsContainer.appendChild(postEl);
          }
        });
        renderTagFilters();
        renderSidebarPanels();
        saveState();
      };

      const createPostElement = (post, index) => {
        const postElement = document.createElement('div');
        postElement.className = 'post fade-in';
        postElement.dataset.id = post.id;
        postElement.dataset.index = index;
        postElement.draggable = true;
        if (post.isPinned) postElement.classList.add('pinned');

        const tagsHtml = post.tags.map(tag => `<span class="tag" data-tag="${tag}">${tag}</span>`).join('');
        const repliesCount = post.replies ? post.replies.length : 0;
        let contentHtml = parseMarkdown(post.content);
        if (currentSearchQuery) {
          const regex = new RegExp(`(${currentSearchQuery})`, 'gi');
          contentHtml = contentHtml.replace(regex, `<span class="highlighted">$1</span>`);
        }
        const imageHtml = post.image ? `<img src="${post.image}" class="post-image" alt="投稿画像">` : '';

        postElement.innerHTML = `
          <div class="post-header">
            <div class="post-meta">
              <span class="timestamp">${new Date(post.timestamp).toLocaleString()}</span>
              ${post.isPinned ? '<span class="stat-item">📌 ピン留め</span>' : ''}
            </div>
            <div class="post-stats">
              <span class="stat-item">💬 ${repliesCount}</span>
              <span class="stat-item">⭐ ${post.favorites}</span>
            </div>
          </div>
          <div class="post-tags">${tagsHtml}</div>
          ${imageHtml}
          <div class="post-content">${contentHtml}</div>
          <div class="post-actions">
            <button class="post-btn btn-reply">💬 返信</button>
            <button class="post-btn btn-favorite ${post.isFavorite ? 'active' : ''}">⭐ お気に入り</button>
            <button class="post-btn btn-edit">✍️ 編集</button>
            <button class="post-btn btn-delete">🗑️ 削除</button>
            <button class="post-btn btn-archive">📦 アーカイブ</button>
            <button class="post-btn btn-pin">${post.isPinned ? '📌 解除' : '📌 ピン'}</button>
            <button class="post-btn btn-export">📤 出力</button>
          </div>
        `;

        if (post.replies && post.replies.length > 0) {
          const repliesContainer = document.createElement('div');
          repliesContainer.style.marginLeft = '20px';
          repliesContainer.style.marginTop = '10px';
          post.replies.forEach(reply => {
            repliesContainer.appendChild(createPostElement(reply, 0));
          });
          postElement.appendChild(repliesContainer);
        }

        // Event listeners
        postElement.querySelector('.btn-reply').addEventListener('click', (e) => {
          e.stopPropagation();
          toggleReplyForm(postElement, post.id);
        });

        postElement.querySelector('.btn-favorite').addEventListener('click', (e) => {
          e.stopPropagation();
          toggleFavorite(post.id);
        });

        postElement.querySelector('.btn-edit').addEventListener('click', (e) => {
          e.stopPropagation();
          editPost(post.id, postElement);
        });

        postElement.querySelector('.btn-delete').addEventListener('click', (e) => {
          e.stopPropagation();
          deletePost(post.id);
        });

        postElement.querySelector('.btn-archive').addEventListener('click', (e) => {
          e.stopPropagation();
          archivePost(post.id);
        });

        postElement.querySelector('.btn-pin').addEventListener('click', (e) => {
          e.stopPropagation();
          togglePin(post.id);
        });

        postElement.querySelector('.btn-export').addEventListener('click', (e) => {
          e.stopPropagation();
          exportPost(post);
        });

        postElement.querySelectorAll('.tag').forEach(tag => {
          tag.addEventListener('click', (e) => {
            e.stopPropagation();
            filterByTag(tag.dataset.tag);
          });
        });

        // Drag and drop
        postElement.addEventListener('dragstart', (e) => {
          draggedPost = index;
          postElement.classList.add('dragging');
        });

        postElement.addEventListener('dragend', (e) => {
          postElement.classList.remove('dragging');
        });

        postElement.addEventListener('dragover', (e) => {
          e.preventDefault();
        });

        postElement.addEventListener('drop', (e) => {
          e.preventDefault();
          const targetIndex = parseInt(postElement.dataset.index);
          if (draggedPost !== null && draggedPost !== targetIndex) {
            const [movedPost] = posts.splice(draggedPost, 1);
            posts.splice(targetIndex, 0, movedPost);
            saveHistory();
            renderPosts();
            showNotification('投稿の順序を変更しました。', 'info');
          }
        });

        return postElement;
      };

      const renderTagFilters = () => {
        tagFilterContainer.innerHTML = '';
        const allTags = new Set();
        posts.forEach(post => {
          post.tags.forEach(tag => allTags.add(tag));
        });

        allTags.forEach(tag => {
          const tagBtn = document.createElement('span');
          tagBtn.className = 'filter-tag';
          tagBtn.textContent = tag;
          tagBtn.dataset.tag = tag;
          if (tag === currentFilterTag) {
            tagBtn.classList.add('active');
          }
          tagBtn.addEventListener('click', () => {
            filterByTag(tag);
          });
          tagFilterContainer.appendChild(tagBtn);
        });
      };

      const renderSidebarPanels = () => {
        favoritesList.innerHTML = '';
        archivesList.innerHTML = '';
        notificationsList.innerHTML = '';

        posts.forEach(post => {
          if (post.isFavorite) {
            const favItem = document.createElement('div');
            favItem.className = 'fav-item';
            favItem.textContent = post.content.substring(0, 50) + '...';
            favItem.dataset.id = post.id;
            favItem.addEventListener('click', () => {
              const el = document.querySelector(`[data-id="${post.id}"]`);
              if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                showNotification('投稿にジャンプしました。', 'info');
              }
            });
            favoritesList.appendChild(favItem);
          }
          if (post.isArchived) {
            const archiveItem = document.createElement('div');
            archiveItem.className = 'archive-item';
            archiveItem.textContent = post.content.substring(0, 50) + '...';
            archiveItem.addEventListener('click', () => {
              post.isArchived = false;
              renderPosts();
              showNotification('アーカイブから復元しました。', 'success');
            });
            archivesList.appendChild(archiveItem);
          }
        });

        notificationHistory.slice(-20).reverse().forEach(notif => {
          const notifItem = document.createElement('div');
          notifItem.className = `notification-item ${notif.type}`;
          notifItem.innerHTML = `
            <div style="font-size:0.8rem;color:#666;">${new Date(notif.timestamp).toLocaleString()}</div>
            <div>${notif.message}</div>
          `;
          notificationsList.appendChild(notifItem);
        });

        updateStatistics();
      };

      const updateStatistics = () => {
        const totalPosts = posts.filter(p => !p.isArchived).length;
        const totalReplies = posts.reduce((sum, post) => sum + (post.replies ? post.replies.length : 0), 0);
        const totalFavorites = posts.reduce((sum, post) => sum + post.favorites, 0);
        const uniqueTags = new Set(posts.flatMap(post => post.tags));
        const archivedCount = posts.filter(p => p.isArchived).length;
        const pinnedCount = posts.filter(p => p.isPinned).length;

        statisticsContent.innerHTML = `
          <p style="padding:10px;border-bottom:1px solid var(--border-color);">📝 総投稿数: <strong>${totalPosts}</strong></p>
          <p style="padding:10px;border-bottom:1px solid var(--border-color);">💬 総返信数: <strong>${totalReplies}</strong></p>
          <p style="padding:10px;border-bottom:1px solid var(--border-color);">⭐ 総お気に入り数: <strong>${totalFavorites}</strong></p>
          <p style="padding:10px;border-bottom:1px solid var(--border-color);">🏷️ 総タグ数: <strong>${uniqueTags.size}</strong></p>
          <p style="padding:10px;border-bottom:1px solid var(--border-color);">📦 アーカイブ数: <strong>${archivedCount}</strong></p>
          <p style="padding:10px;border-bottom:1px solid var(--border-color);">📌 ピン留め数: <strong>${pinnedCount}</strong></p>
          <p style="padding:10px;border-bottom:1px solid var(--border-color);">🔔 通知履歴: <strong>${notificationHistory.length}</strong></p>
        `;
      };

      // Functional Logic (unchanged)
      const addPost = (content, tags, parentId = null, image = null) => {
        if (!content.trim()) {
          showNotification('投稿内容を入力してください。', 'error');
          return;
        }
        const newPost = new Post(content, tags, parentId, image);
        if (parentId) {
          const parentPost = findPostById(posts, parentId);
          if (parentPost) {
            if (!parentPost.replies) parentPost.replies = [];
            parentPost.replies.push(newPost);
            showNotification('返信が投稿されました。', 'success');
          }
        } else {
          posts.unshift(newPost);
          showNotification('新しい投稿が作成されました。', 'success');
        }
        saveHistory();
        renderPosts();
        clearNewPostForm();
      };

      const findPostById = (arr, id) => {
        for (let post of arr) {
          if (post.id === id) return post;
          if (post.replies) {
            const reply = findPostById(post.replies, id);
            if (reply) return reply;
          }
        }
        return null;
      };

      const toggleReplyForm = (postElement, postId) => {
        const existingForm = postElement.querySelector('.reply-form');
        if (existingForm) {
          existingForm.remove();
          return;
        }
        const replyForm = document.createElement('div');
        replyForm.className = 'reply-form';
        replyForm.innerHTML = `
          <textarea class="reply-textarea" placeholder="返信を入力..."></textarea>
          <div class="reply-actions">
            <button class="post-btn btn-primary reply-submit">返信</button>
            <button class="post-btn btn-secondary reply-cancel">キャンセル</button>
          </div>
        `;
        postElement.appendChild(replyForm);
        const submitBtn = replyForm.querySelector('.reply-submit');
        const cancelBtn = replyForm.querySelector('.reply-cancel');
        const textarea = replyForm.querySelector('.reply-textarea');
        submitBtn.addEventListener('click', () => {
          addPost(textarea.value, [], postId);
          replyForm.remove();
        });
        cancelBtn.addEventListener('click', () => {
          replyForm.remove();
        });
      };

      const editPost = (postId, postElement) => {
        const post = findPostById(posts, postId);
        if (!post) return;
        const contentDiv = postElement.querySelector('.post-content');
        const originalContent = post.content;
        contentDiv.innerHTML = `<textarea class="edit-textarea" style="width:100%; min-height:100px; padding:10px; border:1px solid var(--border-color); border-radius:8px;">${originalContent}</textarea>`;
        const textarea = contentDiv.querySelector('.edit-textarea');
        const actionsDiv = postElement.querySelector('.post-actions');
        actionsDiv.innerHTML = `
          <button class="post-btn btn-primary save-edit">💾 保存</button>
          <button class="post-btn btn-secondary cancel-edit">❌ キャンセル</button>
        `;
        postElement.querySelector('.save-edit').addEventListener('click', () => {
          post.content = textarea.value;
          post.timestamp = new Date().toISOString();
          saveHistory();
          renderPosts();
          showNotification('投稿を編集しました。', 'success');
        });
        postElement.querySelector('.cancel-edit').addEventListener('click', () => {
          renderPosts();
        });
      };

      const deletePost = (postId) => {
        const postIndex = posts.findIndex(post => post.id === postId);
        if (postIndex > -1) {
          const deleted = posts.splice(postIndex, 1)[0];
          deletedPosts.push(deleted);
          saveHistory();
          renderPosts();
          showNotification('投稿を削除しました。', 'info');
        }
      };

      const toggleFavorite = (postId) => {
        const post = findPostById(posts, postId);
        if (post) {
          post.isFavorite = !post.isFavorite;
          post.favorites += post.isFavorite ? 1 : -1;
          renderPosts();
          showNotification(post.isFavorite ? 'お気に入りに追加しました。' : 'お気に入りから削除しました。', 'success');
        }
      };

      const archivePost = (postId) => {
        const post = findPostById(posts, postId);
        if (post) {
          post.isArchived = !post.isArchived;
          renderPosts();
          showNotification(post.isArchived ? 'アーカイブしました。' : 'アーカイブから復元しました。', 'info');
        }
      };

      const togglePin = (postId) => {
        const post = findPostById(posts, postId);
        if (post) {
          post.isPinned = !post.isPinned;
          renderPosts();
          showNotification(`投稿を${post.isPinned ? 'ピン留め' : 'ピン解除'}しました。`, 'info');
        }
      };

      const exportPost = (post) => {
        const data = { content: post.content, tags: post.tags, timestamp: post.timestamp, favorites: post.favorites };
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `post_${post.id}.json`;
        a.click();
        URL.revokeObjectURL(url);
        showNotification('投稿をエクスポートしました。', 'success');
      };

      const filterPosts = (postsArray) => {
        let filtered = postsArray;
        if (currentSearchQuery) {
          filtered = filtered.filter(post =>
            post.content.toLowerCase().includes(currentSearchQuery.toLowerCase()) ||
            post.tags.some(tag => tag.toLowerCase().includes(currentSearchQuery.toLowerCase()))
          );
        }
        if (currentFilterTag) {
          filtered = filtered.filter(post => post.tags.includes(currentFilterTag));
        }
        if (advancedFilters.dateFrom) {
          filtered = filtered.filter(post => new Date(post.timestamp) >= new Date(advancedFilters.dateFrom));
        }
        if (advancedFilters.dateTo) {
          const endDate = new Date(advancedFilters.dateTo);
          endDate.setHours(23, 59, 59);
          filtered = filtered.filter(post => new Date(post.timestamp) <= endDate);
        }
        if (advancedFilters.tags.length > 0) {
          filtered = filtered.filter(post => advancedFilters.tags.some(tag => post.tags.includes(tag)));
        }
        if (advancedFilters.favoritesOnly) {
          filtered = filtered.filter(post => post.isFavorite);
        }
        if (advancedFilters.pinnedOnly) {
          filtered = filtered.filter(post => post.isPinned);
        }
        return filtered;
      };

      const sortPosts = (postsArray) => {
        const pinnedPosts = postsArray.filter(post => post.isPinned);
        const nonPinnedPosts = postsArray.filter(post => !post.isPinned);
        let sorted = [...nonPinnedPosts];
        switch(currentSort) {
          case 'new':
            sorted.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            break;
          case 'old':
            sorted.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            break;
          case 'popular':
            sorted.sort((a, b) => b.favorites - a.favorites);
            break;
        }
        return [...pinnedPosts, ...sorted];
      };

      const filterByTag = (tag) => {
        if (currentFilterTag === tag) currentFilterTag = null; else currentFilterTag = tag;
        renderPosts();
      };

      const clearNewPostForm = () => {
        newPostInput.value = '';
        tagInput.value = '';
        currentTags = [];
        currentImage = null;
        imagePreview.style.display = 'none';
        updateCurrentTagsUI();
      };

      const updateCurrentTagsUI = () => {
        currentTagsContainer.innerHTML = '';
        currentTags.forEach(tag => {
          const tagSpan = document.createElement('span');
          tagSpan.className = 'tag';
          tagSpan.textContent = tag;
          const removeBtn = document.createElement('span');
          removeBtn.className = 'tag-removable';
          removeBtn.textContent = ' ×';
          removeBtn.addEventListener('click', () => {
            currentTags = currentTags.filter(t => t !== tag);
            updateCurrentTagsUI();
          });
          tagSpan.appendChild(removeBtn);
          currentTagsContainer.appendChild(tagSpan);
        });
      };

      const toggleSidebarPanel = (panel) => {
        [favoritesPanel, archivesPanel, statisticsPanel, notificationsPanel].forEach(p => {
          if (p !== panel) p.classList.remove('visible');
        });
        panel.classList.toggle('visible');
        overlay.classList.toggle('visible', panel.classList.contains('visible'));
      };

      const toggleSettingsPanel = () => {
        settingsPanel.classList.toggle('visible');
        advancedFilterPanel.classList.remove('visible');
        overlay.classList.toggle('visible');
      };

      const toggleAdvancedFilterPanel = () => {
        advancedFilterPanel.classList.toggle('visible');
        settingsPanel.classList.remove('visible');
        overlay.classList.toggle('visible');
        if (advancedFilterPanel.classList.contains('visible')) updateAdvancedFilterUI();
      };

      const updateAdvancedFilterUI = () => {
        const tagCheckboxes = document.getElementById('tag-checkboxes');
        tagCheckboxes.innerHTML = '';
        const allTags = new Set();
        posts.forEach(post => post.tags.forEach(tag => allTags.add(tag)));
        allTags.forEach(tag => {
          const label = document.createElement('label');
          label.style.display = 'block';
          label.style.marginBottom = '8px';
          label.innerHTML = `<input type="checkbox" value="${tag}" ${advancedFilters.tags.includes(tag) ? 'checked' : ''}> ${tag}`;
          tagCheckboxes.appendChild(label);
        });
      };

      const showNotification = (message, type = 'info', duration = 3000) => {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `<span>${message}</span><span class="close-notification">&times;</span>`;
        notificationArea.prepend(notification);
        notificationHistory.push({ message, type, timestamp: new Date().toISOString() });
        setTimeout(() => { notification.classList.add('visible'); }, 10);
        setTimeout(() => { notification.classList.remove('visible'); setTimeout(() => notification.remove(), 300); }, duration);
        notification.querySelector('.close-notification').addEventListener('click', () => {
          notification.classList.remove('visible');
          setTimeout(() => notification.remove(), 300);
        });
      };

      // Event Listeners
      postBtn.addEventListener('click', () => { addPost(newPostInput.value, currentTags, null, currentImage); });

      addTagBtn.addEventListener('click', () => {
        const tagsToAdd = tagInput.value.split(/\s+/).filter(t => t.trim() !== '');
        currentTags.push(...tagsToAdd);
        tagInput.value = '';
        updateCurrentTagsUI();
      });

      addImageBtn.addEventListener('click', () => { imageInput.click(); });

      imageInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file && file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = (event) => {
            currentImage = event.target.result;
            imagePreview.src = currentImage;
            imagePreview.style.display = 'block';
            showNotification('画像を添付しました。', 'success');
          };
          reader.readAsDataURL(file);
        }
      });

      searchInput.addEventListener('input', () => { currentSearchQuery = searchInput.value.trim(); renderPosts(); });

      darkModeBtn.addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
        const isDark = document.body.classList.contains('dark-mode');
        localStorage.setItem('darkMode', isDark);
        showNotification(isDark ? 'ダークモードON' : 'ダークモードOFF', 'info');
      });

      sortNewBtn.addEventListener('click', () => {
        currentSort = 'new';
        document.querySelectorAll('.header-btn[id^="btn-sort"]').forEach(btn => btn.classList.remove('active'));
        sortNewBtn.classList.add('active');
        renderPosts();
      });

      sortOldBtn.addEventListener('click', () => {
        currentSort = 'old';
        document.querySelectorAll('.header-btn[id^="btn-sort"]').forEach(btn => btn.classList.remove('active'));
        sortOldBtn.classList.add('active');
        renderPosts();
      });

      sortPopularBtn.addEventListener('click', () => {
        currentSort = 'popular';
        document.querySelectorAll('.header-btn[id^="btn-sort"]').forEach(btn => btn.classList.remove('active'));
        sortPopularBtn.classList.add('active');
        renderPosts();
      });

      favoritesBtn.addEventListener('click', () => toggleSidebarPanel(favoritesPanel));
      archivesBtn.addEventListener('click', () => toggleSidebarPanel(archivesPanel));
      notificationsBtn.addEventListener('click', () => toggleSidebarPanel(notificationsPanel));
      statisticsBtn.addEventListener('click', () => toggleSidebarPanel(statisticsPanel));

      settingsBtn.addEventListener('click', toggleSettingsPanel);
      advancedFilterBtn.addEventListener('click', toggleAdvancedFilterPanel);

      overlay.addEventListener('click', () => {
        settingsPanel.classList.remove('visible');
        advancedFilterPanel.classList.remove('visible');
        overlay.classList.remove('visible');
        [favoritesPanel, archivesPanel, statisticsPanel, notificationsPanel].forEach(p => p.classList.remove('visible'));
      });

      undoBtn.addEventListener('click', undo);
      redoBtn.addEventListener('click', redo);

      exportBtn.addEventListener('click', () => {
        const data = { posts, deletedPosts, notificationHistory };
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `board_export_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        showNotification('すべてのデータをエクスポートしました。', 'success');
      });

      clearNotificationsBtn.addEventListener('click', () => {
        notificationHistory = [];
        renderSidebarPanels();
        showNotification('通知履歴をクリアしました。', 'info');
      });

      document.getElementById('apply-advanced-filter').addEventListener('click', () => {
        advancedFilters.dateFrom = document.getElementById('date-from').value;
        advancedFilters.dateTo = document.getElementById('date-to').value;
        advancedFilters.favoritesOnly = document.getElementById('filter-favorites').checked;
        advancedFilters.pinnedOnly = document.getElementById('filter-pinned').checked;
        advancedFilters.tags = [];
        document.querySelectorAll('#tag-checkboxes input:checked').forEach(checkbox => {
          advancedFilters.tags.push(checkbox.value);
        });
        renderPosts();
        advancedFilterPanel.classList.remove('visible');
        overlay.classList.remove('visible');
        showNotification('高度なフィルターを適用しました。', 'success');
      });

      document.getElementById('reset-advanced-filter').addEventListener('click', () => {
        advancedFilters = { dateFrom:null, dateTo:null, tags:[], favoritesOnly:false, pinnedOnly:false };
        document.getElementById('date-from').value = '';
        document.getElementById('date-to').value = '';
        document.getElementById('filter-favorites').checked = false;
        document.getElementById('filter-pinned').checked = false;
        document.querySelectorAll('#tag-checkboxes input').forEach(cb => cb.checked = false);
        renderPosts();
        showNotification('フィルターをリセットしました。', 'info');
      });

      document.getElementById('export-settings').addEventListener('click', () => {
        const settings = { darkMode: document.body.classList.contains('dark-mode'), sort: currentSort, advancedFilters };
        const json = JSON.stringify(settings, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'board_settings.json';
        a.click();
        URL.revokeObjectURL(url);
        showNotification('設定をエクスポートしました。', 'success');
      });

      document.getElementById('import-settings').addEventListener('click', () => {
        document.getElementById('import-settings-input').click();
      });

      document.getElementById('import-settings-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const settings = JSON.parse(event.target.result);
            if (settings.darkMode) document.body.classList.add('dark-mode');
            if (settings.sort) currentSort = settings.sort;
            if (settings.advancedFilters) advancedFilters = settings.advancedFilters;
            renderPosts();
            showNotification('設定をインポートしました。', 'success');
          } catch (error) {
            showNotification('設定ファイルの読み込みに失敗しました。', 'error');
          }
        };
        reader.readAsText(file);
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch(e.key) {
            case 'Enter':
              e.preventDefault();
              if (document.activeElement === newPostInput) postBtn.click();
              break;
            case 'z':
              e.preventDefault(); undo();
              break;
            case 'y':
              e.preventDefault(); redo();
              break;
            case 'd':
              e.preventDefault(); darkModeBtn.click();
              break;
            case 'f':
              e.preventDefault(); searchInput.focus();
              break;
          }
        }
        if (e.key === 'Escape') {
          settingsPanel.classList.remove('visible');
          advancedFilterPanel.classList.remove('visible');
          overlay.classList.remove('visible');
          [favoritesPanel, archivesPanel, statisticsPanel, notificationsPanel].forEach(p => p.classList.remove('visible'));
        }
      });

      // Initialization
      const init = () => {
        loadState();
        if (posts.length === 0) {
          posts.push(new Post('# 掲示板システムへようこそ\n\nこの掲示板システムでは以下の機能が利用できます：\n\n- **Markdown記法対応**（見出し、リスト、コードブロック等）\n- ドラッグ&ドロップによる投稿の並び替え\n- 画像添付機能\n- リアルタイム検索\n- 高度なフィルタリング', ['チュートリアル','はじめに']));
          posts.push(new Post('## プログラミングの質問\n\nJavaScriptで非同期処理を学んでいます。\n\n```javascript\nasync function fetchData() {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}\n```\n\nこのコードについて質問があります。', ['JavaScript','プログラミング']));
          posts.push(new Post('今日は良い天気ですね。\n\n- 散歩に行きました\n- カフェで読書\n- とてもリラックスできました', ['日常','雑談']));
        }
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode === 'true') document.body.classList.add('dark-mode');
        renderPosts();
        updateHistoryButtons();
        saveHistory();
        showNotification('掲示板システムを読み込みました。', 'success', 2000);
      };

      init();

      /* Extra safety: when panels are hidden, ensure they are non-interactive (reinforce CSS approach).
         This guards against edge cases where CSS transition timing might momentarily allow pointer events. */
      const ensurePanelInteractivity = () => {
        [settingsPanel, advancedFilterPanel].forEach(panel => {
          if (!panel.classList.contains('visible')) {
            panel.style.pointerEvents = 'none';
          } else {
            panel.style.pointerEvents = 'auto';
          }
        });
      };
      // Observe class changes to panels (simple interval check to avoid MutationObserver complexity)
      setInterval(ensurePanelInteractivity, 300);

    });
  </script>
</body>
</html>